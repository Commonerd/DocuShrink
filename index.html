<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta
      name="google-site-verification"
      content="U-GWwZOKUY-FqRJYQu4ealLEaLnFK4WTKgDI7SCbS3E"
    />
    <title>
      DocuShrink: Fast & Free PDF Compressor & Merger - Reduce PDF Size, Combine
      PDFs Online
    </title>
    <meta
      name="description"
      content="Instantly compress PDF files to reduce size and merge multiple PDFs into one with DocuShrink. All processing is secure and done locally in your browser. Fast, free, and no uploads needed!"
    />
    <meta
      name="keywords"
      content="PDF compressor, compress PDF, reduce PDF size, PDF merger, merge PDF, combine PDF, online PDF tool, free PDF compressor, fast PDF, secure PDF, local PDF processing, PDF optimizer"
    />

    <link
      rel="icon"
      href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='%234CAF50' d='M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zm2 16H8v-2h8v2zm0-4H8v-2h8v2zm-3-5V3.5L18.5 9H13z'/%3E%3Cpath fill='%23FFC107' d='M10 13l-2 2h4l-2 2zm4-4h-2V7h-2V5h2V3h2v2h2v2h-2z'/%3E%3C/svg%3E"
      type="image/svg+xml"
    />

    <style>
      @import url("https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap");

      :root {
        --primary-color: #4caf50; /* Green */
        --secondary-color: #ffc107; /* Amber */
        --background-color: #f0f2f5;
        --text-color: #333;
        --border-color: #ddd;
        --box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        --danger-color: #f44336;
      }

      body {
        font-family: "Roboto", sans-serif;
        line-height: 1.6;
        color: var(--text-color);
        background-color: var(--background-color);
        margin: 0;
        padding: 20px;
        display: flex;
        flex-direction: column;
        align-items: center;
        min-height: 100vh;
        box-sizing: border-box;
      }

      .container {
        background: #fff;
        padding: 30px;
        border-radius: 12px;
        box-shadow: var(--box-shadow);
        width: 100%;
        max-width: 960px;
        margin-bottom: 20px;
        box-sizing: border-box;
      }

      h1,
      h2 {
        text-align: center;
        color: var(--primary-color);
        margin-bottom: 25px;
        font-weight: 700;
      }

      h1 {
        font-size: 2.8em;
        margin-top: 0;
      }

      h2 {
        font-size: 2em;
        color: var(--secondary-color);
        margin-top: 40px;
        margin-bottom: 20px;
      }

      p {
        text-align: center;
        color: #666;
        margin-bottom: 30px;
        font-size: 1.1em;
      }

      .drop-zone {
        border: 3px dashed var(--primary-color);
        border-radius: 12px;
        padding: 40px 20px;
        text-align: center;
        cursor: pointer;
        font-size: 1.2em;
        color: #777;
        background-color: #f9f9f9;
        transition: background-color 0.3s ease, border-color 0.3s ease;
        margin-bottom: 30px;
      }

      .drop-zone.hover {
        background-color: #e0f7fa;
        border-color: var(--secondary-color);
      }

      .drop-zone input {
        display: none;
      }

      .controls {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 20px;
        margin-bottom: 30px;
      }

      .control-group {
        background: #fdfdfd;
        padding: 20px;
        border-radius: 8px;
        border: 1px solid var(--border-color);
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
      }

      label {
        display: block;
        margin-bottom: 10px;
        font-weight: 600;
        color: var(--text-color);
      }

      select,
      input[type="range"] {
        width: 100%;
        padding: 10px;
        border: 1px solid var(--border-color);
        border-radius: 6px;
        box-sizing: border-box;
        font-size: 1em;
      }

      input[type="range"] {
        -webkit-appearance: none;
        height: 8px;
        background: #ddd;
        outline: none;
        opacity: 0.7;
        transition: opacity 0.2s;
      }

      input[type="range"]:hover {
        opacity: 1;
      }

      input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: var(--primary-color);
        cursor: pointer;
        transition: background 0.3s ease;
      }

      input[type="range"]::-webkit-slider-thumb:hover {
        background: #388e3c;
      }

      .button-group {
        display: flex;
        justify-content: center;
        gap: 20px;
        margin-top: 30px;
        flex-wrap: wrap;
      }

      button {
        background-color: var(--primary-color);
        color: #fff;
        border: none;
        padding: 14px 30px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 1.1em;
        font-weight: 600;
        transition: background-color 0.3s ease, transform 0.2s ease;
        min-width: 180px;
      }

      button:hover {
        background-color: #388e3c;
        transform: translateY(-2px);
      }

      button:active {
        transform: translateY(0);
      }

      .clear-button {
        background-color: #e0e0e0;
        color: var(--text-color);
      }

      .clear-button:hover {
        background-color: #ccc;
      }

      #fileList {
        margin-top: 30px;
        border-top: 1px solid var(--border-color);
        padding-top: 20px;
      }

      .file-item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 12px 0;
        border-bottom: 1px dashed #eee;
      }
      .file-item.merged-output {
        background-color: #e6ffe6; /* Light green for merged output */
        border-color: var(--primary-color);
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 10px;
      }

      .file-item:last-child {
        border-bottom: none;
      }

      .file-info span {
        display: block;
        font-size: 0.95em;
      }

      .file-info .name {
        font-weight: 600;
        color: var(--primary-color);
      }

      .file-info .size {
        font-size: 0.85em;
        color: #777;
      }
      .file-info .status {
        font-size: 0.8em;
        color: #555;
        margin-top: 3px;
      }

      .file-actions button {
        background: none;
        border: none;
        color: var(--danger-color);
        cursor: pointer;
        font-size: 0.9em;
        padding: 5px 10px;
        margin-left: 10px;
        transition: color 0.3s ease;
        min-width: unset; /* Override button min-width */
      }
      .file-actions button.download-file-btn {
        color: var(--secondary-color);
        font-weight: 600;
      }

      .file-actions button:hover {
        color: #ff4500;
      }
      .file-actions button.download-file-btn:hover {
        color: #ffa000;
      }

      .output-section {
        margin-top: 40px;
        text-align: center;
      }

      #mergeSortable {
        display: flex;
        flex-direction: column;
        gap: 8px;
        margin-top: 20px;
        padding: 10px;
        border: 1px dashed #ccc;
        border-radius: 8px;
        min-height: 100px;
        background-color: #fcfcfc;
      }

      .merge-item {
        display: flex;
        align-items: center;
        background-color: #e6e6e6;
        padding: 8px 15px;
        border-radius: 5px;
        cursor: grab;
        font-size: 0.95em;
        color: #444;
        transition: background-color 0.2s ease;
      }
      .merge-item:hover {
        background-color: #dcdcdc;
      }
      .merge-item.dragging {
        opacity: 0.7;
        transform: scale(1.02);
      }
      .merge-item .handle {
        margin-right: 10px;
        font-size: 1.2em;
        cursor: grab;
        color: #888;
      }

      footer {
        margin-top: 40px;
        text-align: center;
        font-size: 0.85em;
        color: #777;
      }

      @media (max-width: 768px) {
        .container {
          padding: 20px;
        }
        h1 {
          font-size: 2.2em;
        }
        h2 {
          font-size: 1.6em;
        }
        p {
          font-size: 1em;
        }
        .drop-zone {
          padding: 30px 15px;
          font-size: 1em;
        }
        .controls {
          grid-template-columns: 1fr;
        }
        button {
          padding: 12px 20px;
          font-size: 1em;
          width: 100%;
          max-width: 280px;
        }
        .button-group {
          flex-direction: column;
          gap: 15px;
        }
      }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf-lib/1.17.1/pdf-lib.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako_inflate.min.js"></script>
  </head>
  <body>
    <div class="container">
      <h1>
        <span style="color: var(--primary-color)">Docu</span
        ><span style="color: var(--secondary-color)">Shrink</span>
      </h1>
      <p>
        Instantly compress and merge your PDF files. Fast, free, and secure â€“
        all in your browser!
      </p>

      <div class="drop-zone" id="dropZone">
        Drag & drop your PDFs here <br />
        or click to select (multiple files accepted)
        <input type="file" id="pdfInput" accept="application/pdf" multiple />
      </div>

      <div id="fileList">
        <p style="text-align: center; color: #888">No PDFs selected yet.</p>
      </div>

      <div class="controls">
        <div class="control-group">
          <label for="quality"
            >Compression Quality: <span id="qualityValue">80</span>%</label
          >
          <input type="range" id="quality" min="10" max="100" value="80" />
        </div>
        <div class="control-group">
          <label for="mergeMode">Merge PDFs:</label>
          <input type="checkbox" id="mergeMode" /> (Drag & drop files below to
          reorder for merging)
        </div>
      </div>

      <div class="button-group">
        <button id="processBtn">Process PDFs</button>
        <button id="clearBtn" class="clear-button">Clear All</button>
      </div>

      <div class="output-section" id="mergeSection" style="display: none">
        <h2>Arrange for Merging</h2>
        <p style="font-size: 0.9em; color: #777">
          Drag and drop PDF files below to arrange their order for merging.
        </p>
        <div id="mergeSortable"></div>
        <button id="mergeBtn" style="margin-top: 20px">
          Merge Selected PDFs
        </button>
      </div>

      <div class="output-section">
        <h2>Processed PDFs</h2>
        <div id="outputFiles" class="output-images">
          <p style="color: #888">Processed PDFs will appear here.</p>
        </div>
      </div>
    </div>

    <footer>
      &copy; 2025 DocuShrink. All rights reserved. |
      <a href="#" style="color: var(--primary-color)">Privacy Policy</a>
    </footer>

    <script>
      const dropZone = document.getElementById("dropZone");
      const pdfInput = document.getElementById("pdfInput");
      const fileListDiv = document.getElementById("fileList");
      const qualityRange = document.getElementById("quality");
      const qualityValueSpan = document.getElementById("qualityValue");
      const mergeModeCheckbox = document.getElementById("mergeMode");
      const processBtn = document.getElementById("processBtn");
      const clearBtn = document.getElementById("clearBtn");
      const outputFilesDiv = document.getElementById("outputFiles");
      const mergeSection = document.getElementById("mergeSection");
      const mergeSortable = document.getElementById("mergeSortable");
      const mergeBtn = document.getElementById("mergeBtn");

      let selectedFiles = []; // Stores actual File objects
      let processedFileBlobs = new Map(); // Stores { fileName: { originalFile: File, optimizedBlob: Blob } }
      let currentDragItem = null; // For drag and drop sorting

      // --- Local Storage based persistence for selected/processed files ---
      // Note: Storing actual Blobs/Files in localStorage is not directly possible
      // We'll store metadata (name, original size, optimized size) and re-process if needed,
      // or more practically, use IndexedDB for larger blob storage.
      // For this example, let's focus on retaining the *list* of files and their statuses.
      // A full-fledged "continue session" would involve IndexedDB to store the PDF Blobs themselves.
      // Here, "sticky" means the *display* of files and their processed status is preserved.

      const LS_KEY = "docuShrinkSession";

      function saveSession() {
        const sessionData = selectedFiles.map((file) => ({
          name: file.name,
          size: file.size,
          type: file.type,
          lastModified: file.lastModified,
          processed: processedFileBlobs.has(file.name), // Mark if processed
        }));
        localStorage.setItem(LS_KEY, JSON.stringify(sessionData));
      }

      function loadSession() {
        const savedData = JSON.parse(localStorage.getItem(LS_KEY));
        if (savedData) {
          // For security and practicality, we don't restore actual files from localStorage.
          // We just display the names, letting users know what they had.
          // For true "resume work", one would need IndexedDB to store the actual PDF binary data.
          // For this project, we'll indicate "processed" status.
          selectedFiles = savedData.map((data) => {
            const mockFile = new File([], data.name, {
              type: data.type,
              lastModified: data.lastModified,
            });
            mockFile.size = data.size; // Manually set size
            return mockFile;
          });
          renderFileList();
          // If a file was processed, display a placeholder for its output,
          // but re-processing would be required to get the actual downloadable blob.
          // This is a simplification due to browser security models.
          // For a truly "sticky" experience with files, IndexedDB would be the way.
        }

        // Load quality setting
        const savedQuality = localStorage.getItem("docuShrinkQuality");
        if (savedQuality) {
          qualityRange.value = savedQuality;
          qualityValueSpan.textContent = savedQuality;
        }
      }

      qualityRange.addEventListener("input", () => {
        qualityValueSpan.textContent = qualityRange.value;
        localStorage.setItem("docuShrinkQuality", qualityRange.value); // Save quality setting
      });

      // --- PDF Processing (Compression & Merging) Logic ---

      async function compressPdf(file, quality) {
        const arrayBuffer = await file.arrayBuffer();
        const pdfDoc = await PDFLib.PDFDocument.load(arrayBuffer, {
          ignoreEncryption: true,
        });

        // Apply compression based on quality (simple strategy: remove unnecessary objects, linearize)
        // PDF-LIB's `save` method handles compression. Lower quality means more aggressive compression.
        const compressedPdfBytes = await pdfDoc.save(); // FIXED: Removed invalid option

        return new Blob([compressedPdfBytes], { type: "application/pdf" });
      }

      async function mergePdfs(pdfFiles) {
        const mergedPdf = await PDFLib.PDFDocument.create();
        for (const file of pdfFiles) {
          const arrayBuffer = await file.arrayBuffer();
          const pdf = await PDFLib.PDFDocument.load(arrayBuffer, {
            ignoreEncryption: true,
          });
          const copiedPages = await mergedPdf.copyPages(
            pdf,
            pdf.getPageIndices()
          );
          copiedPages.forEach((page) => mergedPdf.addPage(page));
        }
        const mergedPdfBytes = await mergedPdf.save();
        return new Blob([mergedPdfBytes], { type: "application/pdf" });
      }

      // --- UI Updates & Event Handlers ---

      function handleFiles(files) {
        Array.from(files).forEach((file) => {
          if (file.type === "application/pdf") {
            selectedFiles.push(file);
          } else {
            alert(`${file.name} is not a PDF file. Please add PDF files only.`);
          }
        });
        renderFileList();
        saveSession();
      }

      dropZone.addEventListener("dragover", (e) => {
        e.preventDefault();
        dropZone.classList.add("hover");
      });

      dropZone.addEventListener("dragleave", () => {
        dropZone.classList.remove("hover");
      });

      dropZone.addEventListener("drop", (e) => {
        e.preventDefault();
        dropZone.classList.remove("hover");
        handleFiles(e.dataTransfer.files);
      });

      dropZone.addEventListener("click", () => {
        pdfInput.click();
      });

      pdfInput.addEventListener("change", (e) => {
        handleFiles(e.target.files);
        e.target.value = "";
      });

      function renderFileList() {
        fileListDiv.innerHTML = "";
        outputFilesDiv.innerHTML =
          '<p style="color:#888;">Processed PDFs will appear here.</p>';
        mergeSortable.innerHTML = ""; // Clear merge sortable list

        if (selectedFiles.length === 0) {
          fileListDiv.innerHTML = `<p style="text-align: center; color: #888;">No PDFs selected yet.</p>`;
          mergeSection.style.display = "none";
          return;
        }

        selectedFiles.forEach((file, index) => {
          const fileItem = document.createElement("div");
          fileItem.className = "file-item";
          fileItem.dataset.index = index; // Store original index for removal
          fileItem.dataset.filename = file.name;

          const processedStatus = processedFileBlobs.has(file.name)
            ? " (Processed)"
            : "";
          const processedBlobInfo = processedFileBlobs.get(file.name);
          const optimizedSizeInfo = processedBlobInfo
            ? `<br>Optimized: <strong>${(
                processedBlobInfo.optimizedBlob.size / 1024
              ).toFixed(2)} KB</strong>`
            : "";
          const downloadButton = processedBlobInfo
            ? `<button class="download-file-btn" data-filename="${file.name}">Download</button>`
            : "";

          fileItem.innerHTML = `
                    <div class="file-info">
                        <span class="name">${file.name}</span>
                        <span class="size">Original: ${(
                          file.size / 1024
                        ).toFixed(2)} KB ${optimizedSizeInfo}</span>
                        <span class="status">${processedStatus}</span>
                    </div>
                    <div class="file-actions">
                        ${downloadButton}
                        <button data-filename="${
                          file.name
                        }" class="remove-file-btn">Remove</button>
                    </div>
                `;
          fileListDiv.appendChild(fileItem);

          // Add to merge sortable if merge mode is on
          if (mergeModeCheckbox.checked) {
            const mergeItem = document.createElement("div");
            mergeItem.className = "merge-item";
            mergeItem.draggable = true;
            mergeItem.dataset.filename = file.name;
            mergeItem.innerHTML = `<span class="handle">â˜°</span> ${file.name}`;
            mergeSortable.appendChild(mergeItem);
          }
        });

        document.querySelectorAll(".remove-file-btn").forEach((button) => {
          button.addEventListener("click", (e) => {
            const filenameToRemove = e.target.dataset.filename;
            selectedFiles = selectedFiles.filter(
              (file) => file.name !== filenameToRemove
            );
            processedFileBlobs.delete(filenameToRemove); // Also remove from processed cache
            renderFileList();
            saveSession();
          });
        });

        document.querySelectorAll(".download-file-btn").forEach((button) => {
          button.addEventListener("click", (e) => {
            const filename = e.target.dataset.filename;
            const blobInfo = processedFileBlobs.get(filename);
            if (blobInfo && blobInfo.optimizedBlob) {
              const url = URL.createObjectURL(blobInfo.optimizedBlob);
              const a = document.createElement("a");
              a.href = url;
              a.download = blobInfo.optimizedFilename;
              document.body.appendChild(a);
              a.click();
              document.body.removeChild(a);
              URL.revokeObjectURL(url); // Clean up
            } else {
              alert("File not yet processed or not found for download.");
            }
          });
        });

        // Drag and drop for merging
        const mergeItems = mergeSortable.querySelectorAll(".merge-item");
        mergeItems.forEach((item) => {
          item.addEventListener("dragstart", (e) => {
            currentDragItem = item;
            e.dataTransfer.effectAllowed = "move";
            item.classList.add("dragging");
          });
          item.addEventListener("dragenter", (e) => {
            e.preventDefault();
            if (item !== currentDragItem) {
              item.style.borderTop = "2px solid var(--primary-color)";
            }
          });
          item.addEventListener("dragleave", () => {
            item.style.borderTop = "";
          });
          item.addEventListener("dragover", (e) => {
            e.preventDefault();
          });
          item.addEventListener("drop", (e) => {
            e.preventDefault();
            if (item !== currentDragItem) {
              const currentRect = currentDragItem.getBoundingClientRect();
              const targetRect = item.getBoundingClientRect();
              const position =
                e.clientY - targetRect.top > targetRect.height / 2
                  ? "after"
                  : "before";

              if (position === "after") {
                mergeSortable.insertBefore(currentDragItem, item.nextSibling);
              } else {
                mergeSortable.insertBefore(currentDragItem, item);
              }
            }
            item.style.borderTop = "";
          });
          item.addEventListener("dragend", () => {
            currentDragItem.classList.remove("dragging");
            currentDragItem = null;
            mergeItems.forEach((i) => (i.style.borderTop = "")); // Clear all borders
          });
        });
      }

      // Toggle merge section visibility
      mergeModeCheckbox.addEventListener("change", () => {
        if (mergeModeCheckbox.checked) {
          mergeSection.style.display = "block";
        } else {
          mergeSection.style.display = "none";
        }
        renderFileList(); // Re-render to show/hide merge items
      });

      // Process PDFs
      processBtn.addEventListener("click", async () => {
        if (selectedFiles.length === 0) {
          alert("Please add PDF files first.");
          return;
        }

        outputFilesDiv.innerHTML = `<p style="text-align: center; color: #888;">Processing PDFs. Please wait...</p>`;
        processedFileBlobs.clear(); // Clear previous processed results

        const quality = parseFloat(qualityRange.value);

        try {
          for (const file of selectedFiles) {
            const optimizedBlob = await compressPdf(file, quality);
            const optimizedFilename = `${file.name.replace(
              ".pdf",
              "_optimized.pdf"
            )}`;
            processedFileBlobs.set(file.name, {
              originalFile: file,
              optimizedBlob: optimizedBlob,
              optimizedFilename: optimizedFilename,
            });
          }
          renderProcessedFiles();
          alert("All PDFs successfully processed!");
          saveSession(); // Save session after processing
        } catch (error) {
          outputFilesDiv.innerHTML = `<p style="color: var(--danger-color); text-align: center;">Error processing PDFs: ${error.message}. Please try again or check file integrity.</p>`;
          console.error("PDF processing error:", error);
        }
      });

      // Merge PDFs
      mergeBtn.addEventListener("click", async () => {
        const filesToMerge = Array.from(mergeSortable.children)
          .map((item) => {
            const filename = item.dataset.filename;
            return selectedFiles.find((file) => file.name === filename);
          })
          .filter(Boolean); // Filter out null/undefined if any

        if (filesToMerge.length < 2) {
          alert(
            'Please add at least two PDFs and arrange them in the "Arrange for Merging" section.'
          );
          return;
        }

        outputFilesDiv.innerHTML = `<p style="text-align: center; color: #888;">Merging PDFs. Please wait...</p>`;

        try {
          const mergedBlob = await mergePdfs(filesToMerge);
          const mergedFilename = `merged_document_${Date.now()}.pdf`;

          const outputItem = document.createElement("div");
          outputItem.className = "file-item merged-output"; // Special class for merged output
          outputItem.innerHTML = `
                    <div class="file-info">
                        <span class="name">Combined PDF: ${mergedFilename}</span>
                        <span class="size">Size: <strong>${(
                          mergedBlob.size / 1024
                        ).toFixed(2)} KB</strong></span>
                    </div>
                    <div class="file-actions">
                        <button class="download-file-btn" data-filename="${mergedFilename}" data-is-merged="true">Download Combined PDF</button>
                    </div>
                `;
          outputFilesDiv.innerHTML = ""; // Clear previous message
          outputFilesDiv.appendChild(outputItem);

          // Store merged blob in processedFileBlobs with a unique key
          processedFileBlobs.set(mergedFilename, {
            optimizedBlob: mergedBlob,
            optimizedFilename: mergedFilename,
          });

          // Attach download event listener for the new merged file
          document
            .querySelector('.download-file-btn[data-is-merged="true"]')
            .addEventListener("click", (e) => {
              const filename = e.target.dataset.filename;
              const blobInfo = processedFileBlobs.get(filename);
              if (blobInfo && blobInfo.optimizedBlob) {
                const url = URL.createObjectURL(blobInfo.optimizedBlob);
                const a = document.createElement("a");
                a.href = url;
                a.download = blobInfo.optimizedFilename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
              }
            });

          alert("PDFs successfully merged!");
          saveSession();
        } catch (error) {
          outputFilesDiv.innerHTML = `<p style="color: var(--danger-color); text-align: center;">Error merging PDFs: ${error.message}.</p>`;
          console.error("PDF merging error:", error);
        }
      });

      function renderProcessedFiles() {
        outputFilesDiv.innerHTML = ""; // Clear previous outputs
        if (processedFileBlobs.size === 0) {
          outputFilesDiv.innerHTML = `<p style="color:#888;">Processed PDFs will appear here.</p>`;
          return;
        }

        processedFileBlobs.forEach((blobInfo, originalFileName) => {
          // Only show individually processed files, merged output has its own display
          if (blobInfo.originalFile) {
            // Check if it's an individually processed file
            const outputItem = document.createElement("div");
            outputItem.className = "file-item";
            const optimizedBlobUrl = URL.createObjectURL(
              blobInfo.optimizedBlob
            );

            outputItem.innerHTML = `
                        <div class="file-info">
                            <span class="name">${
                              blobInfo.optimizedFilename
                            }</span>
                            <span class="size">
                                Original: ${(
                                  blobInfo.originalFile.size / 1024
                                ).toFixed(2)} KB <br>
                                Optimized: <strong>${(
                                  blobInfo.optimizedBlob.size / 1024
                                ).toFixed(2)} KB</strong>
                                (${(
                                  100 -
                                  (blobInfo.optimizedBlob.size /
                                    blobInfo.originalFile.size) *
                                    100
                                ).toFixed(1)}% reduction)
                            </span>
                        </div>
                        <div class="file-actions">
                            <button class="download-file-btn" data-filename="${originalFileName}">Download</button>
                        </div>
                    `;
            outputFilesDiv.appendChild(outputItem);
          }
        });

        // Re-attach download event listeners for all newly rendered buttons
        document.querySelectorAll(".download-file-btn").forEach((button) => {
          button.addEventListener("click", (e) => {
            const filename = e.target.dataset.filename;
            const blobInfo = processedFileBlobs.get(filename);
            if (blobInfo && blobInfo.optimizedBlob) {
              const url = URL.createObjectURL(blobInfo.optimizedBlob);
              const a = document.createElement("a");
              a.href = url;
              a.download = blobInfo.optimizedFilename;
              document.body.appendChild(a);
              a.click();
              document.body.removeChild(a);
              URL.revokeObjectURL(url);
            }
          });
        });
      }

      // Clear All
      clearBtn.addEventListener("click", () => {
        selectedFiles = [];
        processedFileBlobs.clear();
        renderFileList();
        outputFilesDiv.innerHTML = `<p style="color:#888;">Processed PDFs will appear here.</p>`;
        alert("All PDFs and results cleared.");
        localStorage.removeItem(LS_KEY); // Clear session from local storage
      });

      // Initial load
      window.addEventListener("load", () => {
        loadSession(); // Load saved files and settings
        renderFileList(); // Display them
      });
    </script>
  </body>
</html>
