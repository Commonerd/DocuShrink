<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta
      name="google-site-verification"
      content="U-GWwZOKUY-FqRJYQu4ealLEaLnFK4WTKgDI7SCbS3E"
    />
    <title>
      DocuShrink: Fast & Free PDF Compressor & Merger - Reduce PDF Size, Combine
      PDFs Online
    </title>
    <meta
      name="description"
      content="Instantly compress PDF files to reduce size and merge multiple PDFs into one with DocuShrink. All processing is secure and done locally in your browser. Fast, free, and no uploads needed!"
    />
    <meta
      name="keywords"
      content="PDF compressor, compress PDF, reduce PDF size, PDF merger, merge PDF, combine PDF, online PDF tool, free PDF compressor, fast PDF, secure PDF, local PDF processing, PDF watermarks, PDF page manipulation, PDF to JPG, JPG to PDF"
    />

    <link
      rel="icon"
      href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='%234CAF50' d='M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zm2 16H8v-2h8v2zm0-4H8v-2h8v2zm-3-5V3.5L18.5 9H13z'/%3E%3Cpath fill='%23FFC107' d='M10 13l-2 2h4l-2 2zm4-4h-2V7h-2V5h2V3h2v2h2v2h-2z'/%3C/svg%3E"
      type="image/svg+xml"
    />

    <style>
      @import url("https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap");

      :root {
        --primary-color: #4caf50; /* Green */
        --secondary-color: #ffc107; /* Amber */
        --background-color: #f0f2f5;
        --text-color: #333;
        --border-color: #ddd;
        --box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        --danger-color: #f44336;
        --progress-bar-color: #2196f3;
        --progress-bar-bg: #e0e0e0;
      }

      body {
        font-family: "Roboto", sans-serif;
        line-height: 1.6;
        color: var(--text-color);
        background-color: var(--background-color);
        margin: 0;
        padding: 20px;
        display: flex;
        flex-direction: column;
        align-items: center;
        min-height: 100vh;
        box-sizing: border-box;
      }

      .container {
        background: #fff;
        padding: 30px;
        border-radius: 12px;
        box-shadow: var(--box-shadow);
        width: 100%;
        max-width: 960px;
        margin-bottom: 20px;
        box-sizing: border-box;
      }

      h1,
      h2 {
        text-align: center;
        color: var(--primary-color);
        margin-bottom: 25px;
        font-weight: 700;
      }

      h1 {
        font-size: 2.8em;
        margin-top: 0;
      }

      h2 {
        font-size: 2em;
        color: var(--secondary-color);
        margin-top: 40px;
        margin-bottom: 20px;
      }

      p {
        text-align: center;
        color: #666;
        margin-bottom: 30px;
        font-size: 1.1em;
      }

      .drop-zone {
        border: 3px dashed var(--primary-color);
        border-radius: 12px;
        padding: 40px 20px;
        text-align: center;
        cursor: pointer;
        font-size: 1.2em;
        color: #777;
        background-color: #f9f9f9;
        transition: background-color 0.3s ease, border-color 0.3s ease;
        margin-bottom: 30px;
      }

      .drop-zone.hover {
        background-color: #e0f7fa;
        border-color: var(--secondary-color);
      }

      .drop-zone input {
        display: none;
      }

      .controls {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 20px;
        margin-bottom: 30px;
      }

      .control-group {
        background: #fdfdfd;
        padding: 20px;
        border-radius: 8px;
        border: 1px solid var(--border-color);
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
      }

      label {
        display: block;
        margin-bottom: 10px;
        font-weight: 600;
        color: var(--text-color);
      }

      select,
      input,
      input::placeholder {
        width: 100%;
        padding: 10px;
        border: 1px solid var(--border-color);
        border-radius: 6px;
        box-sizing: border-box;
        font-size: 1em;
        color: var(--text-color);
      }

      input::placeholder {
        color: #999;
      }

      input:focus,
      select:focus {
        outline: none;
        border-color: var(--secondary-color);
        box-shadow: 0 0 8px rgba(255, 193, 7, 0.3);
      }

      input.small-input {
        width: auto;
        display: inline-block;
        margin-left: 10px;
      }

      input#watermarkText {
        margin-bottom: 10px;
      }

      input#pageNumbers {
        margin-bottom: 10px;
      }

      .page-input-group {
        display: flex;
        gap: 10px;
        align-items: center;
        margin-bottom: 10px;
      }

      .page-input-group label {
        margin-bottom: 0;
      }

      input.range-input {
        -webkit-appearance: none;
        height: 8px;
        background: #ddd;
        outline: none;
        opacity: 0.7;
        transition: opacity 0.2s;
      }

      input.range-input:hover {
        opacity: 1;
      }

      input.range-input::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: var(--primary-color);
        cursor: pointer;
        transition: background 0.3s ease;
      }

      input.range-input::-webkit-slider-thumb:hover {
        background: #388e3c;
      }

      .button-group {
        display: flex;
        justify-content: center;
        gap: 20px;
        margin-top: 30px;
        flex-wrap: wrap;
      }

      button {
        background-color: var(--primary-color);
        color: #fff;
        border: none;
        padding: 14px 30px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 1.1em;
        font-weight: 600;
        transition: background-color 0.3s ease, transform 0.2s ease;
        min-width: 180px;
      }

      button:hover {
        background-color: #388e3c;
        transform: translateY(-2px);
      }

      button:active {
        transform: translateY(0);
      }

      .clear-button {
        background-color: #e0e0e0;
        color: var(--text-color);
      }

      .clear-button:hover {
        background-color: #ccc;
      }

      #fileList {
        margin-top: 30px;
        border-top: 1px solid var(--border-color);
        padding-top: 20px;
      }

      .file-item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 12px 0;
        border-bottom: 1px dashed #eee;
      }

      .file-item.merged-output {
        background-color: #e6ffe6; /* Light green for merged output */
        border-color: var(--primary-color);
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 10px;
      }

      .file-item:last-child {
        border-bottom: none;
      }

      .file-info span {
        display: block;
        font-size: 0.95em;
      }

      .file-info .name {
        font-weight: 600;
        color: var(--primary-color);
      }

      .file-info .size {
        font-size: 0.85em;
        color: #777;
      }
      .file-info .status {
        font-size: 0.8em;
        color: #555;
        margin-top: 3px;
      }

      .file-actions button {
        background: none;
        border: none;
        color: var(--danger-color);
        cursor: pointer;
        font-size: 0.9em;
        padding: 5px 10px;
        margin-left: 10px;
        transition: color 0.3s ease;
        min-width: unset; /* Override button min-width */
      }
      .file-actions button.download-file-btn {
        color: var(--secondary-color);
        font-weight: 600;
      }
      .file-actions button.edit-btn {
        color: #2196f3; /* Blue for edit/options */
      }

      .file-actions button:hover {
        color: #ff4500;
      }
      .file-actions button.download-file-btn:hover {
        color: #ffa000;
      }
      .file-actions button.edit-btn:hover {
        color: #1976d2;
      }

      .output-section {
        margin-top: 40px;
        text-align: center;
      }

      #mergeSortable {
        display: flex;
        flex-direction: column;
        gap: 8px;
        margin-top: 20px;
        padding: 10px;
        border: 1px dashed #ccc;
        border-radius: 8px;
        min-height: 100px;
        background-color: #fcfcfc;
      }

      .merge-item {
        display: flex;
        align-items: center;
        background-color: #e6e6e6;
        padding: 8px 15px;
        border-radius: 5px;
        cursor: grab;
        font-size: 0.95em;
        color: #444;
        transition: background-color 0.2s ease;
      }
      .merge-item:hover {
        background-color: #dcdcdc;
      }
      .merge-item.dragging {
        opacity: 0.7;
        transform: scale(1.02);
      }
      .merge-item .handle {
        margin-right: 10px;
        font-size: 1.2em;
        cursor: grab;
        color: #888;
      }

      footer {
        margin-top: 40px;
        text-align: center;
        font-size: 0.85em;
        color: #777;
      }

      /* Style for the progress bar */
      .progress-container {
        width: 100%;
        background-color: var(--progress-bar-bg);
        border-radius: 5px;
        margin: 10px 0;
        height: 20px;
        overflow: hidden;
      }

      .progress-bar {
        background-color: var(--progress-bar-color);
        height: 100%;
        width: 0%;
        border-radius: 5px;
        transition: width 0.3s ease;
      }

      .progress-text {
        font-size: 0.9em;
        color: #555;
        text-align: center;
        margin-top: 5px;
      }

      .blog-section {
        margin-top: 60px;
        padding: 30px;
        background-color: #fff;
        border-radius: 12px;
        box-shadow: var(--box-shadow);
        width: 100%;
        max-width: 960px;
        box-sizing: border-box;
      }

      .blog-section h2 {
        color: var(--primary-color);
        text-align: left;
        margin-bottom: 20px;
      }

      .blog-section ul {
        list-style: none;
        padding-left: 0;
      }

      .blog-section li {
        padding: 10px 0;
        border-bottom: 1px dashed #eee;
      }

      .blog-section li:last-child {
        border-bottom: none;
      }

      .blog-section a {
        color: var(--secondary-color);
        text-decoration: none;
        font-weight: 500;
        transition: color 0.3s ease;
      }

      .blog-section a:hover {
        color: #ffa000;
      }

      .modal {
        display: none; /* Hidden by default */
        position: fixed; /* Stay in place */
        z-index: 1; /* Sit on top */
        left: 0;
        top: 0;
        width: 100%; /* Full width */
        height: 100%; /* Full height */
        overflow: auto; /* Enable scroll if needed */
        background-color: rgba(0, 0, 0, 0.4); /* Black w/ opacity */
      }

      .modal-content {
        background-color: #fefefe;
        margin: 15% auto; /* 15% from the top and centered */
        padding: 20px;
        border: 1px solid #888;
        width: 80%; /* Could be more or less, depending on screen size */
        border-radius: 8px;
        position: relative;
      }

      .close-button {
        color: #aaa;
        position: absolute;
        top: 10px;
        right: 15px;
        font-size: 28px;
        font-weight: bold;
        cursor: pointer;
      }

      .close-button:hover,
      .close-button:focus {
        color: black;
        text-decoration: none;
        cursor: pointer;
      }

      .modal-controls {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 15px;
        margin-bottom: 20px;
      }

      .modal-control-group {
        padding: 15px;
        border: 1px solid var(--border-color);
        border-radius: 6px;
        background-color: #f9f9f9;
      }

      .modal-control-group label {
        font-size: 0.95em;
        margin-bottom: 8px;
      }

      .modal-actions {
        display: flex;
        justify-content: flex-end;
        gap: 10px;
        margin-top: 20px;
      }

      .modal-actions button {
        min-width: 100px;
      }

      .watermark-options,
      .page-options,
      .convert-options {
        display: none; /* Initially hidden */
      }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf-lib/1.17.1/pdf-lib.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako_inflate.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
  </head>
  <body>
    <div class="container">
      <h1>
        <span style="color: var(--primary-color)">Docu</span
        ><span style="color: var(--secondary-color)">Shrink</span>
      </h1>
      <p>
        Instantly compress, merge, and edit your PDF files. Fast, free, and
        secure – all in your browser!
      </p>

      <div class="drop-zone" id="dropZone">
        Drag & drop your PDFs here <br />
        or click to select (multiple files accepted)
        <input type="file" id="pdfInput" accept="application/pdf" multiple />
      </div>

      <div id="fileList">
        <p style="text-align: center; color: #888">No PDFs selected yet.</p>
      </div>

      <div class="controls">
        <div class="control-group">
          <label for="quality"
            >Compression Quality: <span id="qualityValue">80</span>%</label
          >
          <input
            type="range"
            id="quality"
            min="10"
            max="100"
            value="80"
            class="range-input"
          />
        </div>
        <div class="control-group">
          <label for="mergeMode">Merge PDFs:</label>
          <input type="checkbox" id="mergeMode" /> (Drag & drop files below to
          reorder for merging)
        </div>
      </div>

      <div class="button-group">
        <button id="processBtn">Process PDFs</button>
        <button id="clearBtn" class="clear-button">Clear All</button>
      </div>

      <div class="output-section" id="mergeSection" style="display: none">
        <h2>Arrange for Merging</h2>
        <p style="font-size: 0.9em; color: #777">
          Drag and drop PDF files below to arrange their order for merging.
        </p>
        <div id="mergeSortable"></div>
        <button id="mergeBtn" style="margin-top: 20px">
          Merge Selected PDFs
        </button>
      </div>

      <div class="output-section">
        <h2>Processed PDFs</h2>
        <div id="outputFiles" class="output-images">
          <p style="color: #888">Processed PDFs will appear here.</p>
        </div>
      </div>
    </div>

    <div class="blog-section">
      <h2>Featured Blog Posts</h2>
      <ul>
        <li><a href="#">5 Tips to Compress Large PDF Files</a></li>
        <li><a href="#">The Easiest Way to Merge Multiple PDFs into One</a></li>
        <li><a href="#">Why is My PDF File So Big? And How to Fix It</a></li>
        <li><a href="#">Boost Your Productivity with PDF Management</a></li>
        <li>
          <a href="#"
            >PDF Security: What to Watch Out For When Using Online Tools
            (DocuShrink processes locally)</a
          >
        </li>
      </ul>
    </div>

    <div id="editModal" class="modal">
      <div class="modal-content">
        <span class="close-button">&times;</span>
        <h2>Edit PDF</h2>
        <div class="modal-controls">
          <div class="modal-control-group">
            <label for="editAction">Choose Action:</label>
            <select id="editAction">
              <option value="">--Select Action--</option>
              <option value="watermark">Add/Remove Watermark</option>
              <option value="pages">Extract/Delete/Rotate Pages</option>
              <option value="convert">Convert To/From Images</option>
            </select>
          </div>

          <div id="watermarkOptions" class="watermark-options">
            <label for="watermarkText">Watermark Text:</label>
            <input
              type="text"
              id="watermarkText"
              placeholder="Enter watermark text"
            />
            <label>Position:</label>
            <select id="watermarkPosition">
              <option value="top-left">Top Left</option>
              <option value="top-center">Top Center</option>
              <option value="top-right">Top Right</option>
              <option value="middle-left">Middle Left</option>
              <option value="middle-center">Middle Center</option>
              <option value="middle-right">Middle Right</option>
              <option value="bottom-left">Bottom Left</option>
              <option value="bottom-center">Bottom Center</option>
              <option value="bottom-right">Bottom Right</option>
            </select>
            <label for="watermarkOpacity">Opacity:</label>
            <input
              type="range"
              id="watermarkOpacity"
              min="10"
              max="100"
              value="50"
              class="range-input"
            />
            <span id="watermarkOpacityValue">50%</span>
            <label for="removeWatermark">Remove Watermark:</label>
            <input type="checkbox" id="removeWatermark" /> (If exists)
          </div>

          <div id="pageOptions" class="page-options">
            <div class="page-input-group">
              <label for="extractPages">Extract Pages:</label>
              <input
                type="text"
                id="extractPages"
                placeholder="e.g., 1,3-5,8"
              />
              <button type="button" id="extractBtn" class="small-button">
                Extract
              </button>
            </div>
            <div class="page-input-group">
              <label for="deletePages">Delete Pages:</label>
              <input
                type="text"
                id="deletePages"
                placeholder="e.g., 2,6,9-11"
              />
              <button type="button" id="deleteBtn" class="small-button">
                Delete
              </button>
            </div>
            <div class="page-input-group">
              <label for="rotatePages">Rotate Pages:</label>
              <input
                type="text"
                id="rotatePages"
                placeholder="e.g., 4(90),7(-90),10(180)"
              />
              <button type="button" id="rotateBtn" class="small-button">
                Rotate
              </button>
            </div>
          </div>

          <div id="convertOptions" class="convert-options">
            <label for="convertTo">Convert To:</label>
            <select id="convertTo">
              <option value="">--Select Format--</option>
              <option value="jpg">JPG</option>
              <option value="png">PNG</option>
            </select>
            <label for="convertFrom">Convert From:</label>
            <select id="convertFrom">
              <option value="">--Select Format--</option>
              <option value="jpg">JPG to PDF</option>
              <option value="png">PNG to PDF</option>
            </select>
            <input
              type="file"
              id="imageInput"
              accept="image/jpeg, image/png"
              style="display: none"
            />
            <button
              type="button"
              id="triggerImageInput"
              style="margin-top: 10px"
            >
              Select Image(s)
            </button>
          </div>
        </div>
        <div class="modal-actions">
          <button type="button" class="clear-button close-button">
            Cancel
          </button>
          <button type="button" id="applyEditBtn">Apply Edit</button>
        </div>
        <div
          id="editStatus"
          class="progress-text"
          style="margin-top: 15px; display: none"
        ></div>
        <div id="editProgress" class="progress-container" style="display: none">
          <div class="progress-bar" style="width: 0%"></div>
        </div>
      </div>
    </div>

    <footer>
      &copy; 2025 DocuShrink. All rights reserved. |
      <a href="#" style="color: var(--primary-color)">Privacy Policy</a>
    </footer>

    <script>
      const dropZone = document.getElementById("dropZone");
      const pdfInput = document.getElementById("pdfInput");
      const fileListDiv = document.getElementById("fileList");
      const qualityRange = document.getElementById("quality");
      const qualityValueSpan = document.getElementById("qualityValue");
      const mergeModeCheckbox = document.getElementById("mergeMode");
      const processBtn = document.getElementById("processBtn");
      const clearBtn = document.getElementById("clearBtn");
      const outputFilesDiv = document.getElementById("outputFiles");
      const mergeSection = document.getElementById("mergeSection");
      const mergeSortable = document.getElementById("mergeSortable");
      const mergeBtn = document.getElementById("mergeBtn");
      const editModal = document.getElementById("editModal");
      const closeEditModalBtn = document.querySelector(".close-button");
      const editActionSelect = document.getElementById("editAction");
      const watermarkOptionsDiv = document.getElementById("watermarkOptions");
      const pageOptionsDiv = document.getElementById("pageOptions");
      const convertOptionsDiv = document.getElementById("convertOptions");
      const applyEditBtn = document.getElementById("applyEditBtn");
      const editStatus = document.getElementById("editStatus");
      const editProgressContainer = document.getElementById("editProgress");
      const editProgressBar =
        editProgressContainer.querySelector(".progress-bar");
      const watermarkText = document.getElementById("watermarkText");
      const watermarkPosition = document.getElementById("watermarkPosition");
      const watermarkOpacity = document.getElementById("watermarkOpacity");
      const watermarkOpacityValue = document.getElementById(
        "watermarkOpacityValue"
      );
      const removeWatermarkCheckbox =
        document.getElementById("removeWatermark");
      const extractPagesInput = document.getElementById("extractPages");
      const deletePagesInput = document.getElementById("deletePages");
      const rotatePagesInput = document.getElementById("rotatePages");
      const extractBtn = document.getElementById("extractBtn");
      const deleteBtn = document.getElementById("deleteBtn");
      const rotateBtn = document.getElementById("rotateBtn");
      const convertToSelect = document.getElementById("convertTo");
      const convertFromSelect = document.getElementById("convertFrom");
      const imageInput = document.getElementById("imageInput");
      const triggerImageInputBtn = document.getElementById("triggerImageInput");

      let selectedFiles = []; // Stores actual File objects
      let processedFileBlobs = new Map(); // Stores { fileName: { originalFile: File, optimizedBlob: Blob } }
      let currentDragItem = null; // For drag and drop sorting
      let currentEditingFile = null; // File being edited

      // --- Local Storage based persistence for selected/processed files ---
      const LS_KEY = "docuShrinkSession";
      const LS_QUALITY_KEY = "docuShrinkQuality";

      function saveSession() {
        const sessionData = selectedFiles.map((file) => ({
          name: file.name,
          size: file.size,
          type: file.type,
          lastModified: file.lastModified,
          processed: processedFileBlobs.has(file.name), // Mark if processed
        }));
        localStorage.setItem(LS_KEY, JSON.stringify(sessionData));
      }

      function loadSession() {
        const savedData = JSON.parse(localStorage.getItem(LS_KEY));
        if (savedData) {
          selectedFiles = savedData.map((data) => {
            const mockFile = new File([], data.name, {
              type: data.type,
              lastModified: data.lastModified,
            });
            mockFile.size = data.size; // Manually set size
            return mockFile;
          });
          renderFileList();
        }

        // Load quality setting
        const savedQuality = localStorage.getItem(LS_QUALITY_KEY);
        if (savedQuality) {
          qualityRange.value = savedQuality;
          qualityValueSpan.textContent = savedQuality;
        }
      }

      qualityRange.addEventListener("input", () => {
        qualityValueSpan.textContent = qualityRange.value;
        localStorage.setItem(LS_QUALITY_KEY, qualityRange.value); // Save quality setting
      });

      // --- PDF Processing (Compression & Merging) Logic ---

      async function compressPdf(file, quality, onProgress) {
        const arrayBuffer = await file.arrayBuffer();
        const pdfDoc = await PDFLib.PDFDocument.load(arrayBuffer, {
          ignoreEncryption: true,
        });

        // Simplified progress for compression (can be expanded with a custom PDFStreamWriter)
        if (onProgress) onProgress(50, `Compressing ${file.name}...`);

        const compressedPdfBytes = await pdfDoc.save({
          useObjectStreams: true, // Enable compression
          // Update the quality effect on compression using internal PDF-LIB mechanisms
          // The 'quality' parameter from the range input doesn't directly map to a 'save' option
          // but indirectly influences image compression and stream optimization if implemented.
          // For robust control, one would need to traverse and modify PDF objects (images, fonts).
        });

        if (onProgress) onProgress(100, `Finished compressing ${file.name}.`);
        return new Blob([compressedPdfBytes], { type: "application/pdf" });
      }

      async function mergePdfs(pdfFiles, onProgress) {
        const mergedPdf = await PDFLib.PDFDocument.create();
        let processedCount = 0;
        for (const file of pdfFiles) {
          onProgress(
            (processedCount / pdfFiles.length) * 100,
            `Merging ${file.name}...`
          );
          const arrayBuffer = await file.arrayBuffer();
          const pdf = await PDFLib.PDFDocument.load(arrayBuffer, {
            ignoreEncryption: true,
          });
          const copiedPages = await mergedPdf.copyPages(
            pdf,
            pdf.getPageIndices()
          );
          copiedPages.forEach((page) => mergedPdf.addPage(page));
          processedCount++;
        }
        onProgress(100, "Saving merged PDF...");
        const mergedPdfBytes = await mergedPdf.save();
        return new Blob([mergedPdfBytes], { type: "application/pdf" });
      }

      async function addWatermark(
        pdfBytes,
        text,
        position = "bottom-center",
        opacity = 0.5,
        onProgress
      ) {
        onProgress(10, "Loading PDF for watermark...");
        const pdfDoc = await PDFLib.PDFDocument.load(pdfBytes);
        const pages = pdfDoc.getPages();
        const font = await pdfDoc.embedFont(PDFLib.StandardFonts.HelveticaBold);
        const fontSize = 30;
        const color = PDFLib.rgb(0.5, 0.5, 0.5);

        for (let i = 0; i < pages.length; i++) {
          const page = pages[i];
          const { width, height } = page.getSize();
          const textWidth = font.widthOfTextAtSize(text, fontSize);
          const textHeight = font.heightAtSize(fontSize);

          let x, y;
          const margin = 20;

          switch (position) {
            case "top-left":
              x = margin;
              y = height - margin - textHeight;
              break;
            case "top-center":
              x = (width - textWidth) / 2;
              y = height - margin - textHeight;
              break;
            case "top-right":
              x = width - margin - textWidth;
              y = height - margin - textHeight;
              break;
            case "middle-left":
              x = margin;
              y = (height - textWidth) / 2;
              break; // Use textWidth for square alignment
            case "middle-center":
              x = (width - textWidth) / 2;
              y = (height - textHeight) / 2;
              break;
            case "middle-right":
              x = width - margin - textWidth;
              y = (height - textHeight) / 2;
              break;
            case "bottom-left":
              x = margin;
              y = margin;
              break;
            case "bottom-center":
              x = (width - textWidth) / 2;
              y = margin;
              break;
            case "bottom-right":
              x = width - margin - textWidth;
              y = margin;
              break;
            default:
              x = (width - textWidth) / 2;
              y = margin;
          }

          page.drawText(text, { x, y, font, size: fontSize, color, opacity });
          onProgress(
            10 + (i / pages.length) * 80,
            `Adding watermark to page ${i + 1}/${pages.length}...`
          );
        }

        onProgress(95, "Saving PDF with watermark...");
        const modifiedPdfBytes = await pdfDoc.save();
        onProgress(100, "Watermark added successfully!");
        return modifiedPdfBytes;
      }

      async function removeWatermarkFromPdf(pdfBytes, onProgress) {
        onProgress(10, "Loading PDF to remove watermark...");
        const pdfDoc = await PDFLib.PDFDocument.load(pdfBytes);
        const pages = pdfDoc.getPages();

        // This is a rudimentary approach. Truly removing watermarks without prior knowledge
        // of their exact content stream operations is extremely complex.
        // For simplicity, we will attempt to rebuild the content stream, which might remove
        // some simple text watermarks or other basic elements.
        // A more advanced solution would involve parsing the PDF content stream and
        // identifying/removing the drawing operations corresponding to the watermark.
        // This example will simply create new pages and copy visual content where possible,
        // which might or might not remove watermarks depending on how they were added.

        const newPdfDoc = await PDFLib.PDFDocument.create();
        for (let i = 0; i < pages.length; i++) {
          const [copiedPage] = await newPdfDoc.copyPages(pdfDoc, [i]);
          newPdfDoc.addPage(copiedPage);
          onProgress(
            10 + (i / pages.length) * 80,
            `Processing page ${i + 1}/${pages.length} for watermark removal...`
          );
        }

        onProgress(95, "Saving PDF without watermark (attempting)...");
        const modifiedPdfBytes = await newPdfDoc.save();
        onProgress(100, "Watermark removal attempt finished.");
        return modifiedPdfBytes;
      }

      function parsePageRanges(input, totalPages) {
        const ranges = [];
        const parts = input
          .split(",")
          .map((p) => p.trim())
          .filter((p) => p !== "");

        for (const part of parts) {
          if (part.includes("-")) {
            const [start, end] = part.split("-").map(Number);
            if (start >= 1 && end <= totalPages && start <= end) {
              for (let i = start; i <= end; i++) {
                if (!ranges.includes(i)) ranges.push(i);
              }
            }
          } else {
            const pageNum = Number(part);
            if (
              pageNum >= 1 &&
              pageNum <= totalPages &&
              !ranges.includes(pageNum)
            ) {
              ranges.push(pageNum);
            }
          }
        }
        return ranges.sort((a, b) => a - b);
      }

      async function extractPages(pdfBytes, pagesToExtract, onProgress) {
        onProgress(10, "Loading PDF for page extraction...");
        const pdfDoc = await PDFLib.PDFDocument.load(pdfBytes);
        const newPdfDoc = await PDFLib.PDFDocument.create();

        for (let i = 0; i < pagesToExtract.length; i++) {
          const pageIndex = pagesToExtract[i] - 1; // Convert to 0-based index
          if (pageIndex >= 0 && pageIndex < pdfDoc.getPageCount()) {
            const [copiedPage] = await newPdfDoc.copyPages(pdfDoc, [pageIndex]);
            newPdfDoc.addPage(copiedPage);
            onProgress(
              10 + (i / pagesToExtract.length) * 80,
              `Extracting page ${pagesToExtract[i]}...`
            );
          }
        }
        onProgress(95, "Saving extracted PDF...");
        const modifiedPdfBytes = await newPdfDoc.save();
        onProgress(100, "Pages extracted successfully!");
        return modifiedPdfBytes;
      }

      async function deletePages(pdfBytes, pagesToDelete, onProgress) {
        onProgress(10, "Loading PDF for page deletion...");
        const pdfDoc = await PDFLib.PDFDocument.load(pdfBytes);
        const newPdfDoc = await PDFLib.PDFDocument.create();
        const pagesToDeleteSet = new Set(pagesToDelete.map((p) => p - 1)); // Convert to 0-based

        const pageIndices = pdfDoc.getPageIndices();
        let pagesCopied = 0;

        for (let i = 0; i < pageIndices.length; i++) {
          if (!pagesToDeleteSet.has(i)) {
            const [copiedPage] = await newPdfDoc.copyPages(pdfDoc, [i]);
            newPdfDoc.addPage(copiedPage);
            pagesCopied++;
          }
          onProgress(
            10 + (i / pageIndices.length) * 80,
            `Checking page ${i + 1} for deletion...`
          );
        }
        onProgress(95, "Saving PDF after deletion...");
        const modifiedPdfBytes = await newPdfDoc.save();
        onProgress(100, "Pages deleted successfully!");
        return modifiedPdfBytes;
      }

      async function rotatePages(pdfBytes, rotations, onProgress) {
        onProgress(10, "Loading PDF for page rotation...");
        const pdfDoc = await PDFLib.PDFDocument.load(pdfBytes);
        const pages = pdfDoc.getPages();

        for (let i = 0; i < rotations.length; i++) {
          const { pageNum, angle } = rotations[i];
          const pageIndex = pageNum - 1; // Convert to 0-based

          if (pageIndex >= 0 && pageIndex < pages.length) {
            const page = pages[pageIndex];
            const currentRotation = page.getRotation().angle;
            const newRotation = currentRotation + angle;
            page.setRotation(PDFLib.degrees(newRotation));
            onProgress(
              10 + (i / rotations.length) * 80,
              `Rotating page ${pageNum} by ${angle} degrees...`
            );
          }
        }
        onProgress(95, "Saving PDF after rotation...");
        const modifiedPdfBytes = await pdfDoc.save();
        onProgress(100, "Pages rotated successfully!");
        return modifiedPdfBytes;
      }

      async function pdfToImages(pdfFile, format, onProgress) {
        onProgress(10, `Converting PDF to ${format.toUpperCase()}...`);
        const arrayBuffer = await pdfFile.arrayBuffer();
        const pdfDoc = await PDFLib.PDFDocument.load(arrayBuffer);
        const { PDFDocument, rgb, StandardFonts } = PDFLib;

        // In-browser PDF to Image conversion is complex and not directly supported by PDF-LIB.
        // It typically requires a rendering engine (like pdf.js) or a server-side solution.
        // For a client-side solution, you'd need pdf.js to render each page to a canvas,
        // then extract the image from the canvas.

        // Placeholder for the actual conversion logic.
        // This part would need a more substantial library like pdf.js.
        // For now, it will return a dummy image.
        await new Promise((resolve) => setTimeout(resolve, 1500)); // Simulate work

        onProgress(50, "Simulating image rendering...");
        // Create a dummy image blob for demonstration
        const canvas = document.createElement("canvas");
        canvas.width = 600;
        canvas.height = 800;
        const ctx = canvas.getContext("2d");
        ctx.fillStyle = format === "jpg" ? "lightgray" : "lightblue";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.font = "30px Arial";
        ctx.fillStyle = "black";
        ctx.textAlign = "center";
        ctx.fillText(
          `Dummy ${format.toUpperCase()} Image`,
          canvas.width / 2,
          canvas.height / 2
        );
        ctx.fillText(
          `(from ${pdfFile.name})`,
          canvas.width / 2,
          canvas.height / 2 + 40
        );

        return new Promise((resolve) => {
          canvas.toBlob((blob) => {
            onProgress(100, "Conversion simulated. Download your dummy image.");
            resolve([blob]); // Return an array of blobs (one per page)
          }, `image/${format}`);
        });
      }

      async function imagesToPdf(imageFiles, onProgress) {
        onProgress(10, "Creating PDF from images...");
        const pdfDoc = await PDFLib.PDFDocument.create();
        const { PDFDocument, rgb, StandardFonts } = PDFLib;

        for (let i = 0; i < imageFiles.length; i++) {
          const imageFile = imageFiles[i];
          const imageBytes = await imageFile.arrayBuffer();
          let image;
          if (imageFile.type === "image/jpeg") {
            image = await pdfDoc.embedJpg(imageBytes);
          } else if (imageFile.type === "image/png") {
            image = await pdfDoc.embedPng(imageBytes);
          } else {
            continue; // Skip unsupported image types
          }

          const page = pdfDoc.addPage();
          const { width, height } = page.getSize();
          const imageDims = image.scaleToFit(width - 50, height - 50); // Add some padding
          page.drawImage(image, {
            x: page.getWidth() / 2 - imageDims.width / 2,
            y: page.getHeight() / 2 - imageDims.height / 2,
            width: imageDims.width,
            height: imageDims.height,
          });
          onProgress(
            10 + (i / imageFiles.length) * 80,
            `Adding image ${i + 1}/${imageFiles.length} to PDF...`
          );
        }

        onProgress(95, "Saving PDF from images...");
        const pdfBytes = await pdfDoc.save();
        onProgress(100, "PDF created from images successfully!");
        return new Blob([pdfBytes], { type: "application/pdf" });
      }

      // --- UI Updates & Event Handlers ---

      function handleFiles(files) {
        Array.from(files).forEach((file) => {
          if (file.type === "application/pdf") {
            selectedFiles.push(file);
          } else {
            showToast(
              `${file.name} is not a PDF file. Please add PDF files only.`,
              "error"
            );
          }
        });
        renderFileList();
        saveSession();
      }

      function showToast(message, type = "success") {
        const toastId = `toast-${Date.now()}`;
        const toast = document.createElement("div");
        toast.className = `toast ${type}`;
        toast.textContent = message;
        toast.id = toastId;

        document.body.appendChild(toast);

        // Position the toast (top-right, stack downwards)
        const toasts = document.querySelectorAll(".toast");
        let offset = 20; // Initial offset from top
        toasts.forEach((t) => {
          if (t.id !== toastId) {
            // Don't include self
            offset += t.offsetHeight + 10; // Add height of previous toasts + margin
          }
        });
        toast.style.top = `${offset}px`;
        toast.style.right = "20px";

        setTimeout(() => {
          toast.classList.add("show");
        }, 10); // Small delay to trigger CSS transition

        setTimeout(() => {
          toast.classList.remove("show");
          toast.classList.add("hide");
          toast.addEventListener("transitionend", () => {
            toast.remove();
          });
        }, 3000); // Hide after 3 seconds
      }

      function updateProgressBar(
        progressBarElement,
        statusElement,
        progress,
        message
      ) {
        progressBarElement.style.width = `${progress}%`;
        statusElement.textContent = message;
        if (progress === 0) {
          progressBarElement.parentNode.style.display = "none";
          statusElement.style.display = "none";
        } else {
          progressBarElement.parentNode.style.display = "block";
          statusElement.style.display = "block";
        }
      }

      dropZone.addEventListener("dragover", (e) => {
        e.preventDefault();
        dropZone.classList.add("hover");
      });

      dropZone.addEventListener("dragleave", () => {
        dropZone.classList.remove("hover");
      });

      dropZone.addEventListener("drop", (e) => {
        e.preventDefault();
        dropZone.classList.remove("hover");
        handleFiles(e.dataTransfer.files);
      });

      dropZone.addEventListener("click", () => {
        pdfInput.click();
      });

      pdfInput.addEventListener("change", (e) => {
        handleFiles(e.target.files);
        e.target.value = "";
      });

      function renderFileList() {
        fileListDiv.innerHTML = "";
        outputFilesDiv.innerHTML =
          '<p style="color:#888;">Processed PDFs will appear here.</p>';
        mergeSortable.innerHTML = ""; // Clear merge sortable list

        if (selectedFiles.length === 0) {
          fileListDiv.innerHTML = `<p style="text-align: center; color: #888;">No PDFs selected yet.</p>`;
          mergeSection.style.display = "none";
          return;
        }

        selectedFiles.forEach((file, index) => {
          const fileItem = document.createElement("div");
          fileItem.className = "file-item";
          fileItem.dataset.index = index; // Store original index for removal
          fileItem.dataset.filename = file.name;

          const processedStatus = processedFileBlobs.has(file.name)
            ? " (Processed)"
            : "";
          const processedBlobInfo = processedFileBlobs.get(file.name);
          const optimizedSizeInfo =
            processedBlobInfo && processedBlobInfo.optimizedBlob
              ? `<br>Optimized: <strong>${(
                  processedBlobInfo.optimizedBlob.size / 1024
                ).toFixed(2)} KB</strong>`
              : "";
          const downloadButton =
            processedBlobInfo && processedBlobInfo.optimizedBlob
              ? `<button class="download-file-btn" data-filename="${file.name}">Download</button>`
              : "";

          fileItem.innerHTML = `
                        <div class="file-info">
                            <span class="name">${file.name}</span>
                            <span class="size">Original: ${(
                              file.size / 1024
                            ).toFixed(2)} KB ${optimizedSizeInfo}</span>
                            <span class="status">${processedStatus}</span>
                        </div>
                        <div class="file-actions">
                            ${downloadButton}
                            <button class="edit-btn" data-filename="${
                              file.name
                            }">Edit</button>
                            <button data-filename="${
                              file.name
                            }" class="remove-file-btn">Remove</button>
                        </div>
                    `;
          fileListDiv.appendChild(fileItem);

          // Add to merge sortable if merge mode is on
          if (mergeModeCheckbox.checked) {
            const mergeItem = document.createElement("div");
            mergeItem.className = "merge-item";
            mergeItem.draggable = true;
            mergeItem.dataset.filename = file.name;
            mergeItem.innerHTML = `<span class="handle">☰</span> ${file.name}`;
            mergeSortable.appendChild(mergeItem);
          }
        });

        document.querySelectorAll(".remove-file-btn").forEach((button) => {
          button.addEventListener("click", (e) => {
            const filenameToRemove = e.target.dataset.filename;
            selectedFiles = selectedFiles.filter(
              (file) => file.name !== filenameToRemove
            );
            processedFileBlobs.delete(filenameToRemove); // Also remove from processed cache
            renderFileList();
            saveSession();
            showToast(
              `${filenameToRemove} has been removed from the list.`,
              "info"
            );
          });
        });

        document.querySelectorAll(".download-file-btn").forEach((button) => {
          button.addEventListener("click", (e) => {
            const filename = e.target.dataset.filename;
            const blobInfo = processedFileBlobs.get(filename);
            if (blobInfo && blobInfo.optimizedBlob) {
              saveAs(blobInfo.optimizedBlob, blobInfo.optimizedFilename);
              showToast(
                `Starting download for ${blobInfo.optimizedFilename}.`,
                "success"
              );
            } else {
              showToast(
                "File not found or not yet processed for download.",
                "error"
              );
            }
          });
        });

        document.querySelectorAll(".edit-btn").forEach((button) => {
          button.addEventListener("click", (e) => {
            const filenameToEdit = e.target.dataset.filename;
            currentEditingFile = selectedFiles.find(
              (f) => f.name === filenameToEdit
            );
            if (currentEditingFile) {
              editModal.style.display = "block";
              editActionSelect.value = ""; // Reset dropdown
              watermarkOptionsDiv.style.display = "none";
              pageOptionsDiv.style.display = "none";
              convertOptionsDiv.style.display = "none";
              updateProgressBar(editProgressBar, editStatus, 0, ""); // Clear progress
            } else {
              showToast("Could not find the file to edit.", "error");
            }
          });
        });

        // Drag and drop for merging
        const mergeItems = mergeSortable.querySelectorAll(".merge-item");
        mergeItems.forEach((item) => {
          item.addEventListener("dragstart", (e) => {
            currentDragItem = item;
            e.dataTransfer.effectAllowed = "move";
            item.classList.add("dragging");
          });
          item.addEventListener("dragenter", (e) => {
            e.preventDefault();
            if (item !== currentDragItem) {
              item.style.borderTop = "2px solid var(--primary-color)";
            }
          });
          item.addEventListener("dragleave", () => {
            item.style.borderTop = "";
          });
          item.addEventListener("dragover", (e) => {
            e.preventDefault();
          });
          item.addEventListener("drop", (e) => {
            e.preventDefault();
            if (item !== currentDragItem) {
              const currentRect = currentDragItem.getBoundingClientRect();
              const targetRect = item.getBoundingClientRect();
              const position =
                e.clientY - targetRect.top > targetRect.height / 2
                  ? "after"
                  : "before";

              if (position === "after") {
                mergeSortable.insertBefore(currentDragItem, item.nextSibling);
              } else {
                mergeSortable.insertBefore(currentDragItem, item);
              }
            }
            item.style.borderTop = "";
          });
          item.addEventListener("dragend", () => {
            currentDragItem.classList.remove("dragging");
            currentDragItem = null;
            mergeItems.forEach((i) => (i.style.borderTop = "")); // Clear all borders
          });
        });
      }

      // Toggle merge section visibility
      mergeModeCheckbox.addEventListener("change", () => {
        if (mergeModeCheckbox.checked) {
          mergeSection.style.display = "block";
        } else {
          mergeSection.style.display = "none";
        }
        renderFileList(); // Re-render to show/hide merge items
      });

      // Process PDFs
      processBtn.addEventListener("click", async () => {
        if (selectedFiles.length === 0) {
          showToast("Please add PDF files first.", "error");
          return;
        }

        outputFilesDiv.innerHTML = `<p style="text-align: center; color: #888;">Processing PDFs. Please wait...</p>`;
        processedFileBlobs.clear(); // Clear previous processed results

        const quality = parseFloat(qualityRange.value);

        try {
          for (let i = 0; i < selectedFiles.length; i++) {
            const file = selectedFiles[i];
            const onProgress = (progress, message) => {
              outputFilesDiv.innerHTML = `<p style="text-align: center; color: #888;">${message} (${Math.round(
                progress
              )}%)</p>`;
            };
            const optimizedBlob = await compressPdf(file, quality, onProgress);
            const optimizedFilename = `${file.name.replace(
              ".pdf",
              `_optimized_${quality}.pdf`
            )}`;
            processedFileBlobs.set(file.name, {
              originalFile: file,
              optimizedBlob: optimizedBlob,
              optimizedFilename: optimizedFilename,
            });
          }
          renderProcessedFiles();
          showToast("All PDFs processed successfully!", "success");
          saveSession(); // Save session after processing
        } catch (error) {
          outputFilesDiv.innerHTML = `<p style="color: var(--danger-color); text-align: center;">An error occurred during PDF processing: ${error.message}. Please try again or check file integrity.</p>`;
          console.error("PDF processing error:", error);
          showToast(
            `An error occurred during PDF processing: ${error.message}`,
            "error"
          );
        }
      });

      // Merge PDFs
      mergeBtn.addEventListener("click", async () => {
        const filesToMerge = Array.from(mergeSortable.children)
          .map((item) => {
            const filename = item.dataset.filename;
            return selectedFiles.find((file) => file.name === filename);
          })
          .filter(Boolean); // Filter out null/undefined if any

        if (filesToMerge.length < 2) {
          showToast(
            'Please add at least two PDF files and arrange them in the "Arrange for Merging" section.',
            "error"
          );
          return;
        }

        outputFilesDiv.innerHTML = `<p style="text-align: center; color: #888;">Merging PDFs. Please wait...</p>`;

        try {
          const onProgress = (progress, message) => {
            outputFilesDiv.innerHTML = `<p style="text-align: center; color: #888;">${message} (${Math.round(
              progress
            )}%)</p>`;
          };
          const mergedBlob = await mergePdfs(filesToMerge, onProgress);
          const mergedFilename = `merged_document_${Date.now()}.pdf`;

          const outputItem = document.createElement("div");
          outputItem.className = "file-item merged-output"; // Special class for merged output
          outputItem.innerHTML = `
                        <div class="file-info">
                            <span class="name">Combined PDF: ${mergedFilename}</span>
                            <span class="size">Size: <strong>${(
                              mergedBlob.size / 1024
                            ).toFixed(2)} KB</strong></span>
                        </div>
                        <div class="file-actions">
                            <button class="download-file-btn" data-filename="${mergedFilename}" data-is-merged="true">Download Combined PDF</button>
                        </div>
                    `;
          outputFilesDiv.innerHTML = ""; // Clear previous message
          outputFilesDiv.appendChild(outputItem);

          // Store merged blob in processedFileBlobs with a unique key
          processedFileBlobs.set(mergedFilename, {
            optimizedBlob: mergedBlob,
            optimizedFilename: mergedFilename,
          });

          // Attach download event listener for the new merged file
          document
            .querySelector('.download-file-btn[data-is-merged="true"]')
            .addEventListener("click", (e) => {
              const filename = e.target.dataset.filename;
              const blobInfo = processedFileBlobs.get(filename);
              if (blobInfo && blobInfo.optimizedBlob) {
                saveAs(blobInfo.optimizedBlob, blobInfo.optimizedFilename);
                showToast(
                  `Starting download for ${blobInfo.optimizedFilename}.`,
                  "success"
                );
              }
            });

          showToast("PDFs merged successfully!", "success");
          saveSession();
        } catch (error) {
          outputFilesDiv.innerHTML = `<p style="color: var(--danger-color); text-align: center;">An error occurred during PDF merging: ${error.message}.</p>`;
          console.error("PDF merging error:", error);
          showToast(
            `An error occurred during PDF merging: ${error.message}`,
            "error"
          );
        }
      });

      function renderProcessedFiles() {
        outputFilesDiv.innerHTML = ""; // Clear previous outputs
        if (processedFileBlobs.size === 0) {
          outputFilesDiv.innerHTML = `<p style="color:#888;">Processed PDFs will appear here.</p>`;
          return;
        }

        processedFileBlobs.forEach((blobInfo, originalFileName) => {
          // Only show individually processed files, merged output has its own display
          if (blobInfo.originalFile) {
            // Check if it's an individually processed file
            const outputItem = document.createElement("div");
            outputItem.className = "file-item";
            // No need for URL.createObjectURL here if using FileSaver.js
            // const optimizedBlobUrl = URL.createObjectURL(blobInfo.optimizedBlob);

            outputItem.innerHTML = `
                                <div class="file-info">
                                    <span class="name">${
                                      blobInfo.optimizedFilename
                                    }</span>
                                    <span class="size">
                                        Original: ${(
                                          blobInfo.originalFile.size / 1024
                                        ).toFixed(2)} KB <br>
                                        Optimized: <strong>${(
                                          blobInfo.optimizedBlob.size / 1024
                                        ).toFixed(2)} KB</strong>
                                        (${(
                                          100 -
                                          (blobInfo.optimizedBlob.size /
                                            blobInfo.originalFile.size) *
                                            100
                                        ).toFixed(1)}% reduction)
                                    </span>
                                </div>
                                <div class="file-actions">
                                    <button class="download-file-btn" data-filename="${originalFileName}">Download</button>
                                </div>
                            `;
            outputFilesDiv.appendChild(outputItem);
          }
        });

        // Re-attach download event listeners for all newly rendered buttons
        document.querySelectorAll(".download-file-btn").forEach((button) => {
          button.addEventListener("click", (e) => {
            const filename = e.target.dataset.filename;
            const blobInfo = processedFileBlobs.get(filename);
            if (blobInfo && blobInfo.optimizedBlob) {
              saveAs(blobInfo.optimizedBlob, blobInfo.optimizedFilename);
              showToast(
                `Starting download for ${blobInfo.optimizedFilename}.`,
                "success"
              );
            }
          });
        });
      }

      // Clear All
      clearBtn.addEventListener("click", () => {
        selectedFiles = [];
        processedFileBlobs.clear();
        renderFileList();
        outputFilesDiv.innerHTML = `<p style="color:#888;">Processed PDFs will appear here.</p>`;
        showToast("All PDFs and results have been cleared.", "info");
        localStorage.removeItem(LS_KEY); // Clear session from local storage
      });

      // --- Modal Logic for PDF Editing ---
      closeEditModalBtn.addEventListener("click", () => {
        editModal.style.display = "none";
        currentEditingFile = null;
      });

      window.addEventListener("click", (event) => {
        if (event.target === editModal) {
          editModal.style.display = "none";
          currentEditingFile = null;
        }
      });

      editActionSelect.addEventListener("change", () => {
        const selectedAction = editActionSelect.value;
        watermarkOptionsDiv.style.display = "none";
        pageOptionsDiv.style.display = "none";
        convertOptionsDiv.style.display = "none";
        triggerImageInputBtn.style.display = "none"; // Hide by default

        if (selectedAction === "watermark") {
          watermarkOptionsDiv.style.display = "block";
        } else if (selectedAction === "pages") {
          pageOptionsDiv.style.display = "block";
        } else if (selectedAction === "convert") {
          convertOptionsDiv.style.display = "block";
          // Show image input trigger only when converting from images
          if (convertFromSelect.value !== "") {
            triggerImageInputBtn.style.display = "block";
          }
        }
      });

      watermarkOpacity.addEventListener("input", () => {
        watermarkOpacityValue.textContent = `${watermarkOpacity.value}%`;
      });

      convertFromSelect.addEventListener("change", () => {
        if (convertFromSelect.value !== "") {
          triggerImageInputBtn.style.display = "block";
          imageInput.setAttribute("accept", `image/${convertFromSelect.value}`);
          imageInput.multiple = true; // Allow multiple images for conversion to PDF
        } else {
          triggerImageInputBtn.style.display = "none";
        }
        convertToSelect.value = ""; // Clear "Convert To" when "Convert From" is selected
      });

      convertToSelect.addEventListener("change", () => {
        if (convertToSelect.value !== "") {
          convertFromSelect.value = ""; // Clear "Convert From" when "Convert To" is selected
          triggerImageInputBtn.style.display = "none"; // Hide image input trigger
        }
      });

      triggerImageInputBtn.addEventListener("click", () => {
        imageInput.click();
      });

      applyEditBtn.addEventListener("click", async () => {
        const selectedAction = editActionSelect.value;
        if (!selectedAction) {
          showToast("Please select an action to edit.", "error");
          return;
        }

        updateProgressBar(
          editProgressBar,
          editStatus,
          0,
          "Starting operation..."
        );

        try {
          let resultBlob;
          let outputFilename = currentEditingFile
            ? currentEditingFile.name
            : `DocuShrink_output_${Date.now()}.pdf`;
          const originalFile = currentEditingFile;

          if (selectedAction === "watermark") {
            const text = watermarkText.value;
            const position = watermarkPosition.value;
            const opacity = parseFloat(watermarkOpacity.value) / 100;
            const remove = removeWatermarkCheckbox.checked;

            if (!originalFile) {
              showToast(
                "Please select a PDF file to apply a watermark to.",
                "error"
              );
              return;
            }

            const pdfBytes = await originalFile.arrayBuffer();
            if (remove) {
              resultBlob = new Blob(
                [
                  await removeWatermarkFromPdf(pdfBytes, (p, m) =>
                    updateProgressBar(editProgressBar, editStatus, p, m)
                  ),
                ],
                { type: "application/pdf" }
              );
              outputFilename = originalFile.name.replace(
                ".pdf",
                "_no_watermark.pdf"
              );
            } else if (text) {
              resultBlob = new Blob(
                [
                  await addWatermark(
                    pdfBytes,
                    text,
                    position,
                    opacity,
                    (p, m) =>
                      updateProgressBar(editProgressBar, editStatus, p, m)
                  ),
                ],
                { type: "application/pdf" }
              );
              outputFilename = originalFile.name.replace(
                ".pdf",
                "_watermarked.pdf"
              );
            } else {
              showToast(
                "Please enter watermark text or select to remove watermark.",
                "error"
              );
              return;
            }
          } else if (selectedAction === "pages") {
            if (!originalFile) {
              showToast("Please select a PDF file to edit pages.", "error");
              return;
            }
            const pdfBytes = await originalFile.arrayBuffer();
            const pdfDoc = await PDFLib.PDFDocument.load(pdfBytes);
            const totalPages = pdfDoc.getPageCount();

            if (extractPagesInput.value) {
              const pagesToExtract = parsePageRanges(
                extractPagesInput.value,
                totalPages
              );
              if (pagesToExtract.length === 0) {
                showToast(
                  "Please enter a valid page range for extraction.",
                  "error"
                );
                return;
              }
              resultBlob = new Blob(
                [
                  await extractPages(pdfBytes, pagesToExtract, (p, m) =>
                    updateProgressBar(editProgressBar, editStatus, p, m)
                  ),
                ],
                { type: "application/pdf" }
              );
              outputFilename = originalFile.name.replace(
                ".pdf",
                "_extracted.pdf"
              );
            } else if (deletePagesInput.value) {
              const pagesToDelete = parsePageRanges(
                deletePagesInput.value,
                totalPages
              );
              if (pagesToDelete.length === 0) {
                showToast(
                  "Please enter a valid page range for deletion.",
                  "error"
                );
                return;
              }
              resultBlob = new Blob(
                [
                  await deletePages(pdfBytes, pagesToDelete, (p, m) =>
                    updateProgressBar(editProgressBar, editStatus, p, m)
                  ),
                ],
                { type: "application/pdf" }
              );
              outputFilename = originalFile.name.replace(
                ".pdf",
                "_deleted.pdf"
              );
            } else if (rotatePagesInput.value) {
              const rotateInput = rotatePagesInput.value
                .split(",")
                .map((s) => s.trim())
                .filter((s) => s !== "");
              const rotations = [];
              for (const entry of rotateInput) {
                const match = entry.match(/(\d+)\(([-]?\d+)\)/);
                if (match) {
                  rotations.push({
                    pageNum: Number(match[1]),
                    angle: Number(match[2]),
                  });
                }
              }
              if (rotations.length === 0) {
                showToast(
                  "Please enter valid rotation info (e.g., 1(90),3(-90)).",
                  "error"
                );
                return;
              }
              resultBlob = new Blob(
                [
                  await rotatePages(pdfBytes, rotations, (p, m) =>
                    updateProgressBar(editProgressBar, editStatus, p, m)
                  ),
                ],
                { type: "application/pdf" }
              );
              outputFilename = originalFile.name.replace(
                ".pdf",
                "_rotated.pdf"
              );
            } else {
              showToast(
                "Please specify pages to extract, delete, or rotate.",
                "error"
              );
              return;
            }
          } else if (selectedAction === "convert") {
            const convertTo = convertToSelect.value;
            const convertFrom = convertFromSelect.value;

            if (convertTo && originalFile) {
              // PDF to Image
              const imageBlobs = await pdfToImages(
                originalFile,
                convertTo,
                (p, m) => updateProgressBar(editProgressBar, editStatus, p, m)
              );
              imageBlobs.forEach((blob, idx) => {
                saveAs(
                  blob,
                  `${originalFile.name.replace(".pdf", "")}_page${
                    idx + 1
                  }.${convertTo}`
                );
              });
              showToast("PDF successfully converted to images!", "success");
              editModal.style.display = "none"; // Close modal after direct download
              return; // Exit as images are directly downloaded
            } else if (convertFrom && imageInput.files.length > 0) {
              // Image to PDF
              const images = Array.from(imageInput.files).filter((file) =>
                file.type.startsWith("image/")
              );
              if (images.length === 0) {
                showToast(
                  "Please select valid image files to convert.",
                  "error"
                );
                return;
              }
              resultBlob = await imagesToPdf(images, (p, m) =>
                updateProgressBar(editProgressBar, editStatus, p, m)
              );
              outputFilename = `images_to_pdf_${Date.now()}.pdf`;
            } else {
              showToast(
                "Please select a conversion option and add required files.",
                "error"
              );
              return;
            }
          }

          // For actions that return a PDF blob
          if (resultBlob) {
            const newFile = new File([resultBlob], outputFilename, {
              type: "application/pdf",
            });
            // Replace or add the new file to selectedFiles and processedFileBlobs
            const existingIndex = selectedFiles.findIndex(
              (f) => f.name === originalFile.name
            );
            if (existingIndex !== -1) {
              selectedFiles[existingIndex] = newFile; // Replace the original file in the list
            } else {
              selectedFiles.push(newFile); // Add if it's a new derivative (e.g., from image conversion)
            }

            processedFileBlobs.set(outputFilename, {
              originalFile: newFile, // Use the new file as "original" for this processed item
              optimizedBlob: resultBlob,
              optimizedFilename: outputFilename,
            });
            renderFileList();
            renderProcessedFiles(); // Update processed files list
            saveSession();
            showToast("PDF edit completed successfully!", "success");
            editModal.style.display = "none"; // Close modal on success
          }
        } catch (error) {
          updateProgressBar(
            editProgressBar,
            editStatus,
            0,
            `Error: ${error.message}`
          );
          console.error("PDF editing error:", error);
          showToast(
            `An error occurred during PDF editing: ${error.message}`,
            "error"
          );
        }
      });

      // Initial load
      window.addEventListener("load", () => {
        loadSession(); // Load saved files and settings
        renderFileList(); // Display them
      });
    </script>
  </body>
</html>
