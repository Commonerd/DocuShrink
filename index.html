<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta
      name="google-site-verification"
      content="U-GWwZOKUY-FqRJYQu4ealLEaLnFK4WTKgDI7SCbS3E"
    />
    <title>
      DocuShrink: Fast & Free PDF Compressor & Merger - Reduce PDF Size, Combine
      PDFs Online
    </title>
    <meta
      name="description"
      content="Instantly compress PDF files to reduce size and merge multiple PDFs into one with DocuShrink. All processing is secure and done locally in your browser. Fast, free, and no uploads needed!"
    />
    <meta
      name="keywords"
      content="PDF compressor, compress PDF, reduce PDF size, PDF merger, merge PDF, combine PDF, online PDF tool, free PDF compressor, fast PDF, secure PDF, local PDF processing, PDF optimizer"
    />

    <link
      rel="icon"
      href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='%234CAF50' d='M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zm2 16H8v-2h8v2zm0-4H8v-2h8v2zm-3-5V3.5L18.5 9H13z'/%3E%3Cpath fill='%23FFC107' d='M10 13l-2 2h4l-2 2zm4-4h-2V7h-2V5h2V3h2v2h2v2h-2z'/%3E%3C/svg%3E"
      type="image/svg+xml"
    />

    <style>
      @import url("https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap");

      :root {
        --primary-color: #4caf50; /* Green */
        --secondary-color: #ffc107; /* Amber */
        --background-color: #f0f2f5;
        --text-color: #333;
        --border-color: #ddd;
        --box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        --danger-color: #f44336;
      }

      body {
        font-family: "Roboto", sans-serif;
        line-height: 1.6;
        color: var(--text-color);
        background-color: var(--background-color);
        margin: 0;
        padding: 20px;
        display: flex;
        flex-direction: column;
        align-items: center;
        min-height: 100vh;
        box-sizing: border-box;
      }

      .container {
        background: #fff;
        padding: 30px;
        border-radius: 12px;
        box-shadow: var(--box-shadow);
        width: 100%;
        max-width: 960px;
        margin-bottom: 20px;
        box-sizing: border-box;
      }

      h1,
      h2 {
        text-align: center;
        color: var(--primary-color);
        margin-bottom: 25px;
        font-weight: 700;
      }

      h1 {
        font-size: 2.8em;
        margin-top: 0;
      }

      h2 {
        font-size: 2em;
        color: var(--secondary-color);
        margin-top: 40px;
        margin-bottom: 20px;
      }

      p {
        text-align: center;
        color: #666;
        margin-bottom: 30px;
        font-size: 1.1em;
      }

      .drop-zone {
        border: 3px dashed var(--primary-color);
        border-radius: 12px;
        padding: 40px 20px;
        text-align: center;
        cursor: pointer;
        font-size: 1.2em;
        color: #777;
        background-color: #f9f9f9;
        transition: background-color 0.3s ease, border-color 0.3s ease;
        margin-bottom: 30px;
      }

      .drop-zone.hover {
        background-color: #e0f7fa;
        border-color: var(--secondary-color);
      }

      .drop-zone input {
        display: none;
      }

      .controls {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 20px;
        margin-bottom: 30px;
      }

      .control-group {
        background: #fdfdfd;
        padding: 20px;
        border-radius: 8px;
        border: 1px solid var(--border-color);
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
      }

      label {
        display: block;
        margin-bottom: 10px;
        font-weight: 600;
        color: var(--text-color);
      }

      select,
      input[type="range"],
      input[type="text"] {
        width: 100%;
        padding: 10px;
        border: 1px solid var(--border-color);
        border-radius: 6px;
        box-sizing: border-box;
        font-size: 1em;
      }

      input[type="range"] {
        -webkit-appearance: none;
        height: 8px;
        background: #ddd;
        outline: none;
        opacity: 0.7;
        transition: opacity 0.2s;
      }

      input[type="range"]:hover {
        opacity: 1;
      }

      input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: var(--primary-color);
        cursor: pointer;
        transition: background 0.3s ease;
      }

      input[type="range"]::-webkit-slider-thumb:hover {
        background: #388e3c;
      }

      .button-group {
        display: flex;
        justify-content: center;
        gap: 20px;
        margin-top: 30px;
        flex-wrap: wrap;
      }

      button {
        background-color: var(--primary-color);
        color: #fff;
        border: none;
        padding: 14px 30px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 1.1em;
        font-weight: 600;
        transition: background-color 0.3s ease, transform 0.2s ease;
        min-width: 180px;
      }

      button:hover {
        background-color: #388e3c;
        transform: translateY(-2px);
      }

      button:active {
        transform: translateY(0);
      }

      .clear-button {
        background-color: #e0e0e0;
        color: var(--text-color);
      }

      .clear-button:hover {
        background-color: #ccc;
      }

      #fileList {
        margin-top: 30px;
        border-top: 1px solid var(--border-color);
        padding-top: 20px;
      }

      .file-item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 12px 0;
        border-bottom: 1px dashed #eee;
      }
      .file-item.merged-output {
        background-color: #e6ffe6; /* Light green for merged output */
        border-color: var(--primary-color);
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 10px;
      }

      .file-item:last-child {
        border-bottom: none;
      }

      .file-info span {
        display: block;
        font-size: 0.95em;
      }

      .file-info .name {
        font-weight: 600;
        color: var(--primary-color);
      }

      .file-info .size {
        font-size: 0.85em;
        color: #777;
      }
      .file-info .status {
        font-size: 0.8em;
        color: #555;
        margin-top: 3px;
      }

      .file-actions button {
        background: none;
        border: none;
        color: var(--danger-color);
        cursor: pointer;
        font-size: 0.9em;
        padding: 5px 10px;
        margin-left: 10px;
        transition: color 0.3s ease;
        min-width: unset; /* Override button min-width */
      }
      .file-actions button.download-file-btn {
        color: var(--secondary-color);
        font-weight: 600;
      }

      .file-actions button:hover {
        color: #ff4500;
      }
      .file-actions button.download-file-btn:hover {
        color: #ffa000;
      }

      .output-section {
        margin-top: 40px;
        text-align: center;
      }

      #mergeSortable {
        display: flex;
        flex-direction: column;
        gap: 8px;
        margin-top: 20px;
        padding: 10px;
        border: 1px dashed #ccc;
        border-radius: 8px;
        min-height: 100px;
        background-color: #fcfcfc;
      }

      .merge-item {
        display: flex;
        align-items: center;
        background-color: #e6e6e6;
        padding: 8px 15px;
        border-radius: 5px;
        cursor: grab;
        font-size: 0.95em;
        color: #444;
        transition: background-color 0.2s ease;
      }
      .merge-item:hover {
        background-color: #dcdcdc;
      }
      .merge-item.dragging {
        opacity: 0.7;
        transform: scale(1.02);
      }
      .merge-item .handle {
        margin-right: 10px;
        font-size: 1.2em;
        cursor: grab;
        color: #888;
      }

      footer {
        margin-top: 40px;
        text-align: center;
        font-size: 0.85em;
        color: #777;
      }

      @media (max-width: 768px) {
        .container {
          padding: 20px;
        }
        h1 {
          font-size: 2.2em;
        }
        h2 {
          font-size: 1.6em;
        }
        p {
          font-size: 1em;
        }
        .drop-zone {
          padding: 30px 15px;
          font-size: 1em;
        }
        .controls {
          grid-template-columns: 1fr;
        }
        button {
          padding: 12px 20px;
          font-size: 1em;
          width: 100%;
          max-width: 280px;
        }
        .button-group {
          flex-direction: column;
          gap: 15px;
        }
      }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf-lib/1.17.1/pdf-lib.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako_inflate.min.js"></script>
  </head>
  <body>
    <div class="container">
      <h1>
        <span style="color: var(--primary-color)">Docu</span
        ><span style="color: var(--secondary-color)">Shrink</span>
      </h1>
      <p>
        Instantly compress, merge, extract, delete pages, and rotate your PDF
        files. Fast, free, and secure â€“ all in your browser!
      </p>

      <div class="drop-zone" id="dropZone">
        Drag & drop your PDFs here <br />
        or click to select (multiple files accepted)
        <input type="file" id="pdfInput" accept="application/pdf" multiple />
      </div>

      <div id="fileList">
        <p style="text-align: center; color: #888">No PDFs selected yet.</p>
      </div>

      <div class="controls">
        <div class="control-group">
          <label for="quality"
            >Compression Quality: <span id="qualityValue">80</span>%</label
          >
          <input type="range" id="quality" min="10" max="100" value="80" />
        </div>
        <div class="control-group">
          <label for="mergeMode">Merge PDFs:</label>
          <input type="checkbox" id="mergeMode" /> (Drag & drop files below to
          reorder for merging)
        </div>

        <div class="control-group">
          <label for="extractPagesInput">Extract Pages (e.g., 1-3, 5):</label>
          <input
            type="text"
            id="extractPagesInput"
            placeholder="e.g., 1-3, 5, 7-END"
          />
          <button
            id="extractPagesBtn"
            style="margin-top: 10px; min-width: unset; padding: 10px 15px"
          >
            Extract Pages
          </button>
        </div>

        <div class="control-group">
          <label for="deletePagesInput">Delete Pages (e.g., 2, 4-6):</label>
          <input type="text" id="deletePagesInput" placeholder="e.g., 2, 4-6" />
          <button
            id="deletePagesBtn"
            style="margin-top: 10px; min-width: unset; padding: 10px 15px"
          >
            Delete Pages
          </button>
        </div>

        <div class="control-group">
          <label for="rotatePagesInput">Rotate Pages (e.g., 1, 3-5):</label>
          <input
            type="text"
            id="rotatePagesInput"
            placeholder="e.g., ALL or 1, 3-5"
          />
          <label for="rotationDegrees" style="margin-top: 10px"
            >Rotation:</label
          >
          <select id="rotationDegrees">
            <option value="90">90Â° Clockwise</option>
            <option value="180">180Â°</option>
            <option value="270">270Â° Clockwise</option>
          </select>
          <button
            id="rotatePagesBtn"
            style="margin-top: 10px; min-width: unset; padding: 10px 15px"
          >
            Rotate Pages
          </button>
        </div>
      </div>

      <div class="button-group">
        <button id="processBtn">Process PDFs (Compress)</button>
        <button id="clearBtn" class="clear-button">Clear All</button>
      </div>

      <div class="output-section" id="mergeSection" style="display: none">
        <h2>Arrange for Merging</h2>
        <p style="font-size: 0.9em; color: #777">
          Drag and drop PDF files below to arrange their order for merging.
        </p>
        <div id="mergeSortable"></div>
        <button id="mergeBtn" style="margin-top: 20px">
          Merge Selected PDFs
        </button>
      </div>

      <div class="output-section">
        <h2>Processed PDFs</h2>
        <div id="outputFiles" class="output-images">
          <p style="color: #888">Processed PDFs will appear here.</p>
        </div>
      </div>
    </div>

    <footer>
      &copy; 2025 DocuShrink. All rights reserved. |
      <a href="#" style="color: var(--primary-color)">Privacy Policy</a>
    </footer>

    <script>
      // Import the 'degrees' function from PDF-LIB.
      const { PDFDocument, StandardFonts, rgb, degrees } = PDFLib;

      const dropZone = document.getElementById("dropZone");
      const pdfInput = document.getElementById("pdfInput");
      const fileListDiv = document.getElementById("fileList");
      const qualityRange = document.getElementById("quality");
      const qualityValueSpan = document.getElementById("qualityValue");
      const mergeModeCheckbox = document.getElementById("mergeMode");
      const processBtn = document.getElementById("processBtn");
      const clearBtn = document.getElementById("clearBtn");
      const outputFilesDiv = document.getElementById("outputFiles");
      const mergeSection = document.getElementById("mergeSection");
      const mergeSortable = document.getElementById("mergeSortable");
      const mergeBtn = document.getElementById("mergeBtn");

      // New elements for page manipulation
      const extractPagesInput = document.getElementById("extractPagesInput");
      const extractPagesBtn = document.getElementById("extractPagesBtn");
      const deletePagesInput = document.getElementById("deletePagesInput");
      const deletePagesBtn = document.getElementById("deletePagesBtn");
      const rotatePagesInput = document.getElementById("rotatePagesInput");
      const rotationDegreesSelect = document.getElementById("rotationDegrees");
      const rotatePagesBtn = document.getElementById("rotatePagesBtn");

      let selectedFiles = []; // Stores actual File objects
      let processedFileBlobs = new Map(); // Stores { fileName: { originalFile: File, optimizedBlob: Blob } }
      let currentDragItem = null; // For drag and drop sorting

      // --- Local Storage based persistence for selected/processed files ---
      const LS_KEY = "docuShrinkSession";

      function saveSession() {
        const sessionData = selectedFiles.map((file) => ({
          name: file.name,
          size: file.size,
          type: file.type,
          lastModified: file.lastModified,
          processed: processedFileBlobs.has(file.name), // Mark if processed
        }));
        localStorage.setItem(LS_KEY, JSON.stringify(sessionData));
      }

      function loadSession() {
        const savedData = JSON.parse(localStorage.getItem(LS_KEY));
        if (savedData) {
          selectedFiles = savedData.map((data) => {
            const mockFile = new File([], data.name, {
              type: data.type,
              lastModified: data.lastModified,
            });
            mockFile.size = data.size; // Manually set size
            return mockFile;
          });
          renderFileList();
        }

        const savedQuality = localStorage.getItem("docuShrinkQuality");
        if (savedQuality) {
          qualityRange.value = savedQuality;
          qualityValueSpan.textContent = savedQuality;
        }
      }

      qualityRange.addEventListener("input", () => {
        qualityValueSpan.textContent = qualityRange.value;
        localStorage.setItem("docuShrinkQuality", qualityRange.value);
      });

      // --- PDF Processing (Compression, Merging, Extraction, Deletion, Rotation) Logic ---

      async function compressPdf(file, quality) {
        const arrayBuffer = await file.arrayBuffer();
        const pdfDoc = await PDFDocument.load(arrayBuffer, {
          ignoreEncryption: true,
        });
        const compressedPdfBytes = await pdfDoc.save();
        return new Blob([compressedPdfBytes], { type: "application/pdf" });
      }

      async function mergePdfs(pdfFiles) {
        const mergedPdf = await PDFDocument.create();
        for (const file of pdfFiles) {
          const arrayBuffer = await file.arrayBuffer();
          const pdf = await PDFDocument.load(arrayBuffer, {
            ignoreEncryption: true,
          });
          const copiedPages = await mergedPdf.copyPages(
            pdf,
            pdf.getPageIndices()
          );
          copiedPages.forEach((page) => mergedPdf.addPage(page));
        }
        const mergedPdfBytes = await mergedPdf.save();
        return new Blob([mergedPdfBytes], { type: "application/pdf" });
      }

      function parsePageRanges(rangeString, totalPages) {
        const pages = new Set();
        const parts = rangeString.split(",").map((s) => s.trim());

        for (const part of parts) {
          if (part.includes("-")) {
            let [start, end] = part.split("-").map((s) => s.trim());
            start = parseInt(start);
            end = end.toLowerCase() === "end" ? totalPages : parseInt(end);

            if (
              isNaN(start) ||
              isNaN(end) ||
              start < 1 ||
              end > totalPages || // This condition might cause "Invalid page range" error for valid ranges like "1-END" if totalPages is not yet known or is being parsed relative to 0-indexed. Let's adjust for clarity.
              start > end
            ) {
              throw new Error(`Invalid page range: ${part}`);
            }
            for (let i = start; i <= end; i++) {
              pages.add(i - 1); // PDF-LIB is 0-indexed
            }
          } else {
            const pageNum = parseInt(part);
            if (isNaN(pageNum) || pageNum < 1 || pageNum > totalPages) {
              throw new Error(`Invalid page number: ${part}`);
            }
            pages.add(pageNum - 1); // PDF-LIB is 0-indexed
          }
        }
        return Array.from(pages).sort((a, b) => a - b);
      }

      async function extractPdfPages(file, pagesToExtract) {
        const arrayBuffer = await file.arrayBuffer();
        const pdfDoc = await PDFDocument.load(arrayBuffer, {
          ignoreEncryption: true,
        });
        const newPdfDoc = await PDFDocument.create();

        const pageIndices = parsePageRanges(
          pagesToExtract,
          pdfDoc.getPageCount()
        );
        if (pageIndices.length === 0) {
          throw new Error("No valid pages specified for extraction.");
        }

        const copiedPages = await newPdfDoc.copyPages(pdfDoc, pageIndices);
        copiedPages.forEach((page) => newPdfDoc.addPage(page));

        const extractedPdfBytes = await newPdfDoc.save();
        return new Blob([extractedPdfBytes], { type: "application/pdf" });
      }

      async function deletePdfPages(file, pagesToDelete) {
        const arrayBuffer = await file.arrayBuffer();
        const pdfDoc = await PDFDocument.load(arrayBuffer, {
          ignoreEncryption: true,
        });

        const pagesToRemoveIndices = parsePageRanges(
          pagesToDelete,
          pdfDoc.getPageCount()
        );

        // Remove pages in reverse order to avoid issues with shifting indices
        for (let i = pagesToRemoveIndices.length - 1; i >= 0; i--) {
          pdfDoc.removePage(pagesToRemoveIndices[i]);
        }

        const modifiedPdfBytes = await pdfDoc.save();
        return new Blob([modifiedPdfBytes], { type: "application/pdf" });
      }

      async function rotatePdfPages(file, pagesToRotate, rotationAngle) {
        const arrayBuffer = await file.arrayBuffer();
        const pdfDoc = await PDFDocument.load(arrayBuffer, {
          ignoreEncryption: true,
        });

        let pageIndicesToRotate;
        if (pagesToRotate.toLowerCase() === "all") {
          pageIndicesToRotate = pdfDoc.getPageIndices();
        } else {
          pageIndicesToRotate = parsePageRanges(
            pagesToRotate,
            pdfDoc.getPageCount()
          );
        }

        // Use the 'degrees' function to specify the rotation angle.
        const rotation = degrees(parseInt(rotationAngle));

        if (isNaN(rotationAngle) || !rotation) {
          // Check if rotation is valid (degrees function might return NaN for invalid input)
          throw new Error("Invalid rotation angle specified.");
        }

        for (const index of pageIndicesToRotate) {
          const page = pdfDoc.getPages()[index];
          // Set new rotation, or add to existing if you want cumulative rotation
          page.setRotation(rotation);
        }

        const rotatedPdfBytes = await pdfDoc.save();
        return new Blob([rotatedPdfBytes], { type: "application/pdf" });
      }

      // --- UI Updates & Event Handlers ---

      function handleFiles(files) {
        Array.from(files).forEach((file) => {
          if (file.type === "application/pdf") {
            selectedFiles.push(file);
          } else {
            alert(`${file.name} is not a PDF file. Please add PDF files only.`);
          }
        });
        renderFileList();
        saveSession();
      }

      dropZone.addEventListener("dragover", (e) => {
        e.preventDefault();
        dropZone.classList.add("hover");
      });

      dropZone.addEventListener("dragleave", () => {
        dropZone.classList.remove("hover");
      });

      dropZone.addEventListener("drop", (e) => {
        e.preventDefault();
        dropZone.classList.remove("hover");
        handleFiles(e.dataTransfer.files);
      });

      dropZone.addEventListener("click", () => {
        pdfInput.click();
      });

      pdfInput.addEventListener("change", (e) => {
        handleFiles(e.target.files);
        e.target.value = "";
      });

      function renderFileList() {
        fileListDiv.innerHTML = "";
        outputFilesDiv.innerHTML =
          '<p style="color:#888;">Processed PDFs will appear here.</p>';
        mergeSortable.innerHTML = ""; // Clear merge sortable list

        if (selectedFiles.length === 0) {
          fileListDiv.innerHTML = `<p style="text-align: center; color: #888;">No PDFs selected yet.</p>`;
          mergeSection.style.display = "none";
          return;
        }

        selectedFiles.forEach((file, index) => {
          const fileItem = document.createElement("div");
          fileItem.className = "file-item";
          fileItem.dataset.index = index;
          fileItem.dataset.filename = file.name;

          const processedStatus = processedFileBlobs.has(file.name)
            ? " (Processed)"
            : "";
          const processedBlobInfo = processedFileBlobs.get(file.name);
          const optimizedSizeInfo = processedBlobInfo
            ? `<br>Optimized: <strong>${(
                processedBlobInfo.optimizedBlob.size / 1024
              ).toFixed(2)} KB</strong>`
            : "";
          const downloadButton = processedBlobInfo
            ? `<button class="download-file-btn" data-filename="${file.name}">Download</button>`
            : "";

          fileItem.innerHTML = `
                        <div class="file-info">
                            <span class="name">${file.name}</span>
                            <span class="size">Original: ${(
                              file.size / 1024
                            ).toFixed(2)} KB ${optimizedSizeInfo}</span>
                            <span class="status">${processedStatus}</span>
                        </div>
                        <div class="file-actions">
                            ${downloadButton}
                            <button data-filename="${
                              file.name
                            }" class="remove-file-btn">Remove</button>
                        </div>
                `;
          fileListDiv.appendChild(fileItem);

          if (mergeModeCheckbox.checked) {
            const mergeItem = document.createElement("div");
            mergeItem.className = "merge-item";
            mergeItem.draggable = true;
            mergeItem.dataset.filename = file.name;
            mergeItem.innerHTML = `<span class="handle">â˜°</span> ${file.name}`;
            mergeSortable.appendChild(mergeItem);
          }
        });

        document.querySelectorAll(".remove-file-btn").forEach((button) => {
          button.addEventListener("click", (e) => {
            const filenameToRemove = e.target.dataset.filename;
            selectedFiles = selectedFiles.filter(
              (file) => file.name !== filenameToRemove
            );
            processedFileBlobs.delete(filenameToRemove);
            renderFileList();
            saveSession();
          });
        });

        document.querySelectorAll(".download-file-btn").forEach((button) => {
          button.addEventListener("click", (e) => {
            const filename = e.target.dataset.filename;
            const blobInfo = processedFileBlobs.get(filename);
            if (blobInfo && blobInfo.optimizedBlob) {
              const url = URL.createObjectURL(blobInfo.optimizedBlob);
              const a = document.createElement("a");
              a.href = url;
              a.download = blobInfo.optimizedFilename;
              document.body.appendChild(a);
              a.click();
              document.body.removeChild(a);
              URL.revokeObjectURL(url);
            } else {
              alert("File not yet processed or not found for download.");
            }
          });
        });

        // Drag and drop for merging
        const mergeItems = mergeSortable.querySelectorAll(".merge-item");
        mergeItems.forEach((item) => {
          item.addEventListener("dragstart", (e) => {
            currentDragItem = item;
            e.dataTransfer.effectAllowed = "move";
            item.classList.add("dragging");
          });
          item.addEventListener("dragenter", (e) => {
            e.preventDefault();
            if (item !== currentDragItem) {
              item.style.borderTop = "2px solid var(--primary-color)";
            }
          });
          item.addEventListener("dragleave", () => {
            item.style.borderTop = "";
          });
          item.addEventListener("dragover", (e) => {
            e.preventDefault();
          });
          item.addEventListener("drop", (e) => {
            e.preventDefault();
            if (item !== currentDragItem) {
              const currentRect = currentDragItem.getBoundingClientRect();
              const targetRect = item.getBoundingClientRect();
              const position =
                e.clientY - targetRect.top > targetRect.height / 2
                  ? "after"
                  : "before";

              if (position === "after") {
                mergeSortable.insertBefore(currentDragItem, item.nextSibling);
              } else {
                mergeSortable.insertBefore(currentDragItem, item);
              }
            }
            item.style.borderTop = "";
          });
          item.addEventListener("dragend", () => {
            currentDragItem.classList.remove("dragging");
            currentDragItem = null;
            mergeItems.forEach((i) => (i.style.borderTop = ""));
          });
        });
      }

      mergeModeCheckbox.addEventListener("change", () => {
        if (mergeModeCheckbox.checked) {
          mergeSection.style.display = "block";
        } else {
          mergeSection.style.display = "none";
        }
        renderFileList();
      });

      processBtn.addEventListener("click", async () => {
        if (selectedFiles.length === 0) {
          alert("Please add PDF files first.");
          return;
        }

        outputFilesDiv.innerHTML = `<p style="text-align: center; color: #888;">Processing PDFs. Please wait...</p>`;
        processedFileBlobs.clear();

        const quality = parseFloat(qualityRange.value);

        try {
          for (const file of selectedFiles) {
            const optimizedBlob = await compressPdf(file, quality);
            const optimizedFilename = `${file.name.replace(
              ".pdf",
              "_optimized.pdf"
            )}`;
            processedFileBlobs.set(file.name, {
              originalFile: file,
              optimizedBlob: optimizedBlob,
              optimizedFilename: optimizedFilename,
            });
          }
          renderProcessedFiles(); // Call this function to display processed files
          alert("All PDFs successfully processed!");
          saveSession();
        } catch (error) {
          outputFilesDiv.innerHTML = `<p style="color: var(--danger-color); text-align: center;">Error processing PDFs: ${error.message}. Please try again or check file integrity.</p>`;
          console.error("PDF processing error:", error);
        }
      });

      mergeBtn.addEventListener("click", async () => {
        const filesToMerge = Array.from(mergeSortable.children)
          .map((item) => {
            const filename = item.dataset.filename;
            return selectedFiles.find((file) => file.name === filename);
          })
          .filter(Boolean);

        if (filesToMerge.length < 2) {
          alert(
            'Please add at least two PDFs and arrange them in the "Arrange for Merging" section.'
          );
          return;
        }

        outputFilesDiv.innerHTML = `<p style="text-align: center; color: #888;">Merging PDFs. Please wait...</p>`;

        try {
          const mergedBlob = await mergePdfs(filesToMerge);
          const mergedFilename = `merged_document_${Date.now()}.pdf`;

          const outputItem = document.createElement("div");
          outputItem.className = "file-item merged-output";
          outputItem.innerHTML = `
                        <div class="file-info">
                            <span class="name">Combined PDF: ${mergedFilename}</span>
                            <span class="size">Size: <strong>${(
                              mergedBlob.size / 1024
                            ).toFixed(2)} KB</strong></span>
                        </div>
                        <div class="file-actions">
                            <button class="download-file-btn" data-filename="${mergedFilename}" data-is-merged="true">Download Combined PDF</button>
                        </div>
                `;
          outputFilesDiv.innerHTML = "";
          outputFilesDiv.appendChild(outputItem);

          processedFileBlobs.set(mergedFilename, {
            optimizedBlob: mergedBlob,
            optimizedFilename: mergedFilename,
          });

          document
            .querySelector('.download-file-btn[data-is-merged="true"]')
            .addEventListener("click", (e) => {
              const filename = e.target.dataset.filename;
              const blobInfo = processedFileBlobs.get(filename);
              if (blobInfo && blobInfo.optimizedBlob) {
                const url = URL.createObjectURL(blobInfo.optimizedBlob);
                const a = document.createElement("a");
                a.href = url;
                a.download = blobInfo.optimizedFilename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
              }
            });

          alert("PDFs successfully merged!");
          saveSession();
        } catch (error) {
          outputFilesDiv.innerHTML = `<p style="color: var(--danger-color); text-align: center;">Error merging PDFs: ${error.message}.</p>`;
          console.error("PDF merging error:", error);
        }
      });

      // Function to render processed files in the output section
      function renderProcessedFiles() {
        outputFilesDiv.innerHTML = "";
        if (processedFileBlobs.size === 0) {
          outputFilesDiv.innerHTML = `<p style="color:#888;">Processed PDFs will appear here.</p>`;
          return;
        }

        processedFileBlobs.forEach((blobInfo, originalFileName) => {
          // If it's a merged file, it's already rendered by mergeBtn.
          // This check prevents duplicate rendering of merged files if they are in `processedFileBlobs`.
          if (blobInfo.optimizedFilename.startsWith("merged_document_")) {
            return;
          }

          const fileItem = document.createElement("div");
          fileItem.className = "file-item";
          fileItem.innerHTML = `
                        <div class="file-info">
                            <span class="name">Processed: ${
                              blobInfo.optimizedFilename
                            }</span>
                            <span class="size">Size: <strong>${(
                              blobInfo.optimizedBlob.size / 1024
                            ).toFixed(2)} KB</strong></span>
                        </div>
                        <div class="file-actions">
                            <button class="download-file-btn" data-filename="${
                              blobInfo.optimizedFilename
                            }">Download</button>
                        </div>
                    `;
          outputFilesDiv.appendChild(fileItem);

          // Add event listener for the new download button
          fileItem
            .querySelector(".download-file-btn")
            .addEventListener("click", (e) => {
              const filename = e.target.dataset.filename;
              // Find the correct blob by its *optimized* filename since that's what's stored now for download
              const foundBlobInfo = Array.from(
                processedFileBlobs.values()
              ).find((info) => info.optimizedFilename === filename);
              if (foundBlobInfo && foundBlobInfo.optimizedBlob) {
                const url = URL.createObjectURL(foundBlobInfo.optimizedBlob);
                const a = document.createElement("a");
                a.href = url;
                a.download = foundBlobInfo.optimizedFilename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
              } else {
                alert("Processed file not found for download.");
              }
            });
        });
      }

      clearBtn.addEventListener("click", () => {
        selectedFiles = [];
        processedFileBlobs.clear();
        localStorage.removeItem(LS_KEY);
        localStorage.removeItem("docuShrinkQuality");
        qualityRange.value = 80;
        qualityValueSpan.textContent = 80;
        extractPagesInput.value = "";
        deletePagesInput.value = "";
        rotatePagesInput.value = "";
        rotationDegreesSelect.value = 90;
        renderFileList();
        alert("All files and session data cleared.");
      });

      extractPagesBtn.addEventListener("click", async () => {
        if (selectedFiles.length === 0) {
          alert("Please add a PDF file first to extract pages.");
          return;
        }
        if (selectedFiles.length > 1) {
          alert("Please select only one PDF file for page extraction.");
          return;
        }

        const file = selectedFiles[0];
        const pagesToExtract = extractPagesInput.value.trim();

        if (!pagesToExtract) {
          alert("Please enter the pages to extract (e.g., 1-3, 5).");
          return;
        }

        outputFilesDiv.innerHTML = `<p style="text-align: center; color: #888;">Extracting pages. Please wait...</p>`;

        try {
          const extractedBlob = await extractPdfPages(file, pagesToExtract);
          const extractedFilename = `${file.name.replace(
            ".pdf",
            `_extracted_pages_${pagesToExtract.replace(
              /[^a-zA-Z0-9-]/g,
              "_"
            )}.pdf`
          )}`;

          const outputItem = document.createElement("div");
          outputItem.className = "file-item";
          outputItem.innerHTML = `
                        <div class="file-info">
                            <span class="name">Extracted: ${extractedFilename}</span>
                            <span class="size">Size: <strong>${(
                              extractedBlob.size / 1024
                            ).toFixed(2)} KB</strong></span>
                        </div>
                        <div class="file-actions">
                            <button class="download-file-btn" data-filename="${extractedFilename}">Download Extracted PDF</button>
                        </div>
                    `;
          outputFilesDiv.innerHTML = "";
          outputFilesDiv.appendChild(outputItem);

          // Store the extracted blob for download
          processedFileBlobs.set(extractedFilename, {
            optimizedBlob: extractedBlob,
            optimizedFilename: extractedFilename,
          });

          // Add event listener for the new download button
          outputItem
            .querySelector(".download-file-btn")
            .addEventListener("click", (e) => {
              const filename = e.target.dataset.filename;
              const blobInfo = processedFileBlobs.get(filename);
              if (blobInfo && blobInfo.optimizedBlob) {
                const url = URL.createObjectURL(blobInfo.optimizedBlob);
                const a = document.createElement("a");
                a.href = url;
                a.download = blobInfo.optimizedFilename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
              }
            });

          alert("Pages successfully extracted!");
        } catch (error) {
          outputFilesDiv.innerHTML = `<p style="color: var(--danger-color); text-align: center;">Error extracting pages: ${error.message}.</p>`;
          console.error("PDF extraction error:", error);
        }
      });

      deletePagesBtn.addEventListener("click", async () => {
        if (selectedFiles.length === 0) {
          alert("Please add a PDF file first to delete pages.");
          return;
        }
        if (selectedFiles.length > 1) {
          alert("Please select only one PDF file for page deletion.");
          return;
        }

        const file = selectedFiles[0];
        const pagesToDelete = deletePagesInput.value.trim();

        if (!pagesToDelete) {
          alert("Please enter the pages to delete (e.g., 2, 4-6).");
          return;
        }

        outputFilesDiv.innerHTML = `<p style="text-align: center; color: #888;">Deleting pages. Please wait...</p>`;

        try {
          const modifiedBlob = await deletePdfPages(file, pagesToDelete);
          const modifiedFilename = `${file.name.replace(
            ".pdf",
            `_pages_deleted.pdf`
          )}`;

          const outputItem = document.createElement("div");
          outputItem.className = "file-item";
          outputItem.innerHTML = `
                        <div class="file-info">
                            <span class="name">Modified: ${modifiedFilename}</span>
                            <span class="size">Size: <strong>${(
                              modifiedBlob.size / 1024
                            ).toFixed(2)} KB</strong></span>
                        </div>
                        <div class="file-actions">
                            <button class="download-file-btn" data-filename="${modifiedFilename}">Download Modified PDF</button>
                        </div>
                    `;
          outputFilesDiv.innerHTML = "";
          outputFilesDiv.appendChild(outputItem);

          // Store the modified blob for download
          processedFileBlobs.set(modifiedFilename, {
            optimizedBlob: modifiedBlob,
            optimizedFilename: modifiedFilename,
          });

          // Add event listener for the new download button
          outputItem
            .querySelector(".download-file-btn")
            .addEventListener("click", (e) => {
              const filename = e.target.dataset.filename;
              const blobInfo = processedFileBlobs.get(filename);
              if (blobInfo && blobInfo.optimizedBlob) {
                const url = URL.createObjectURL(blobInfo.optimizedBlob);
                const a = document.createElement("a");
                a.href = url;
                a.download = blobInfo.optimizedFilename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
              }
            });

          alert("Pages successfully deleted!");
        } catch (error) {
          outputFilesDiv.innerHTML = `<p style="color: var(--danger-color); text-align: center;">Error deleting pages: ${error.message}.</p>`;
          console.error("PDF deletion error:", error);
        }
      });

      rotatePagesBtn.addEventListener("click", async () => {
        if (selectedFiles.length === 0) {
          alert("Please add a PDF file first to rotate pages.");
          return;
        }
        if (selectedFiles.length > 1) {
          alert("Please select only one PDF file for page rotation.");
          return;
        }

        const file = selectedFiles[0];
        const pagesToRotate = rotatePagesInput.value.trim();
        const rotationAngle = rotationDegreesSelect.value;

        if (!pagesToRotate) {
          alert("Please enter the pages to rotate (e.g., ALL or 1, 3-5).");
          return;
        }

        outputFilesDiv.innerHTML = `<p style="text-align: center; color: #888;">Rotating pages. Please wait...</p>`;

        try {
          const rotatedBlob = await rotatePdfPages(
            file,
            pagesToRotate,
            rotationAngle
          );
          const rotatedFilename = `${file.name.replace(
            ".pdf",
            `_rotated_${rotationAngle}.pdf`
          )}`;

          const outputItem = document.createElement("div");
          outputItem.className = "file-item";
          outputItem.innerHTML = `
                        <div class="file-info">
                            <span class="name">Rotated: ${rotatedFilename}</span>
                            <span class="size">Size: <strong>${(
                              rotatedBlob.size / 1024
                            ).toFixed(2)} KB</strong></span>
                        </div>
                        <div class="file-actions">
                            <button class="download-file-btn" data-filename="${rotatedFilename}">Download Rotated PDF</button>
                        </div>
                    `;
          outputFilesDiv.innerHTML = "";
          outputFilesDiv.appendChild(outputItem);

          // Store the rotated blob for download
          processedFileBlobs.set(rotatedFilename, {
            optimizedBlob: rotatedBlob,
            optimizedFilename: rotatedFilename,
          });

          // Add event listener for the new download button
          outputItem
            .querySelector(".download-file-btn")
            .addEventListener("click", (e) => {
              const filename = e.target.dataset.filename;
              const blobInfo = processedFileBlobs.get(filename);
              if (blobInfo && blobInfo.optimizedBlob) {
                const url = URL.createObjectURL(blobInfo.optimizedBlob);
                const a = document.createElement("a");
                a.href = url;
                a.download = blobInfo.optimizedFilename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
              }
            });

          alert("Pages successfully rotated!");
        } catch (error) {
          outputFilesDiv.innerHTML = `<p style="color: var(--danger-color); text-align: center;">Error rotating pages: ${error.message}.</p>`;
          console.error("PDF rotation error:", error);
        }
      });

      // Initial load
      loadSession();
    </script>
  </body>
</html>
